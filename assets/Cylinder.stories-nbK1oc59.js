import{p as ce,s as ge,r as ke,i as Ve,a as we,t as Ce}from"./props-CDwtXEPn.js";import{p as de,a as ye,f as ve,g as Se,n as Ue,s as pe,d as ze}from"./index-client-0IVJ1HVs.js";import{t as X,M as A,x as Pe,m as ue,l as G,V as E,y as _e,v as le,u as Ee,j as Te,c as Le,d as De,C as Ae,E as Ne,S as Oe,F as Ie,H as Me}from"./create-runtime-stories-W9W7bo9k.js";import"./iframe-Dg-i1owp.js";import"../sb-preview/runtime.js";import"./index-D-8MO0q_.js";import"./index-BHYIh-Xd.js";import"./_commonjsHelpers-Cpj98o6Y.js";function fe(n){const a=n.height||2;let f=n.diameterTop===0?0:n.diameterTop||n.diameter||1,p=n.diameterBottom===0?0:n.diameterBottom||n.diameter||1;f=f||1e-5,p=p||1e-5;const t=(n.tessellation||24)|0,h=(n.subdivisions||1)|0,y=!!n.hasRings,C=!!n.enclose,N=n.cap===0?0:n.cap||A.CAP_ALL,T=n.arc&&(n.arc<=0||n.arc>1)?1:n.arc||1,W=n.sideOrientation===0?0:n.sideOrientation||X.DEFAULTSIDE,i=n.faceUV||new Array(3),s=n.faceColors,B=T!==1&&C?2:0,J=y?h:1,I=2+(1+B)*J;let m;for(m=0;m<I;m++)s&&s[m]===void 0&&(s[m]=new ue(1,1,1,1));for(m=0;m<I;m++)i&&i[m]===void 0&&(i[m]=new G(0,0,1,1));const r=[],b=[],l=[],g=[],v=[],Y=Math.PI*2*T/t;let M,L,R;const Z=(p-f)/2/a,c=E.Zero(),o=E.Zero(),O=E.Zero(),k=E.Zero(),d=E.Zero(),ee=_e.Y;let u,x,F,te=1,e=1,j=0,S=0;for(u=0;u<=h;u++)for(L=u/h,R=(L*(f-p)+p)/2,te=y&&u!==0&&u!==h?2:1,F=0;F<te;F++){for(y&&(e+=F),C&&(e+=2*F),x=0;x<=t;x++)M=x*Y,c.x=Math.cos(-M)*R,c.y=-a/2+L*a,c.z=Math.sin(-M)*R,f===0&&u===h?(o.x=l[l.length-(t+1)*3],o.y=l[l.length-(t+1)*3+1],o.z=l[l.length-(t+1)*3+2]):(o.x=c.x,o.z=c.z,o.y=Math.sqrt(o.x*o.x+o.z*o.z)*Z,o.normalize()),x===0&&(O.copyFrom(c),k.copyFrom(o)),b.push(c.x,c.y,c.z),l.push(o.x,o.y,o.z),y?S=j!==e?i[e].y:i[e].w:S=i[e].y+(i[e].w-i[e].y)*L,g.push(i[e].x+(i[e].z-i[e].x)*x/t,S),s&&v.push(s[e].r,s[e].g,s[e].b,s[e].a);T!==1&&C&&(b.push(c.x,c.y,c.z),b.push(0,c.y,0),b.push(0,c.y,0),b.push(O.x,O.y,O.z),E.CrossToRef(ee,o,d),d.normalize(),l.push(d.x,d.y,d.z,d.x,d.y,d.z),E.CrossToRef(k,ee,d),d.normalize(),l.push(d.x,d.y,d.z,d.x,d.y,d.z),y?S=j!==e?i[e+1].y:i[e+1].w:S=i[e+1].y+(i[e+1].w-i[e+1].y)*L,g.push(i[e+1].x,S),g.push(i[e+1].z,S),y?S=j!==e?i[e+2].y:i[e+2].w:S=i[e+2].y+(i[e+2].w-i[e+2].y)*L,g.push(i[e+2].x,S),g.push(i[e+2].z,S),s&&(v.push(s[e+1].r,s[e+1].g,s[e+1].b,s[e+1].a),v.push(s[e+1].r,s[e+1].g,s[e+1].b,s[e+1].a),v.push(s[e+2].r,s[e+2].g,s[e+2].b,s[e+2].a),v.push(s[e+2].r,s[e+2].g,s[e+2].b,s[e+2].a))),j!==e&&(j=e)}const q=T!==1&&C?t+4:t;for(u=0,e=0;e<h;e++){let V=0,U=0,z=0,D=0;for(x=0;x<t;x++)V=u*(q+1)+x,U=(u+1)*(q+1)+x,z=u*(q+1)+(x+1),D=(u+1)*(q+1)+(x+1),r.push(V,U,z),r.push(D,z,U);T!==1&&C&&(r.push(V+2,U+2,z+2),r.push(D+2,z+2,U+2),r.push(V+4,U+4,z+4),r.push(D+4,z+4,U+4)),u=y?u+2:u+1}const se=V=>{const U=V?f/2:p/2;if(U===0)return;let z,D,P;const w=V?i[I-1]:i[0];let _=null;s&&(_=V?s[I-1]:s[0]);const H=b.length/3,ne=V?a/2:-a/2,K=new E(0,ne,0);b.push(K.x,K.y,K.z),l.push(0,V?1:-1,0);const be=w.y+(w.w-w.y)*.5;g.push(w.x+(w.z-w.x)*.5,be),_&&v.push(_.r,_.g,_.b,_.a);const ie=new le(.5,.5);for(P=0;P<=t;P++){z=Math.PI*2*P*T/t;const ae=Math.cos(-z),oe=Math.sin(-z);D=new E(ae*U,ne,oe*U);const re=new le(ae*ie.x+.5,oe*ie.y+.5);b.push(D.x,D.y,D.z),l.push(0,V?1:-1,0);const xe=w.y+(w.w-w.y)*re.y;g.push(w.x+(w.z-w.x)*re.x,xe),_&&v.push(_.r,_.g,_.b,_.a)}for(P=0;P<t;P++)V?(r.push(H),r.push(H+(P+2)),r.push(H+(P+1))):(r.push(H),r.push(H+(P+1)),r.push(H+(P+2)))};(N===A.CAP_START||N===A.CAP_ALL)&&se(!1),(N===A.CAP_END||N===A.CAP_ALL)&&se(!0),X._ComputeSides(W,b,r,l,g,n.frontUVs,n.backUVs);const $=new X;return $.indices=r,$.positions=b,$.normals=l,$.uvs=g,s&&($.colors=v),$}function he(n,a={},f){const p=new A(n,f);return a.sideOrientation=A._GetDefaultSideOrientation(a.sideOrientation),p._originalBuilderSideOrientation=a.sideOrientation,fe(a).applyToMesh(p,a.updatable),p}X.CreateCylinder=fe;A.CreateCylinder=(n,a,f,p,t,h,y,C,N)=>((y===void 0||!(y instanceof Pe))&&(y!==void 0&&(N=C||A.DEFAULTSIDE,C=y),y=h,h=1),he(n,{height:a,diameterTop:f,diameterBottom:p,tessellation:t,subdivisions:h,sideOrientation:N,updatable:C},y));function Q(n,a){de(a,!0);let f=ce(a,"mesh",15),p=ce(a,"physicsShape",19,()=>Ee.CYLINDER),t=ke(a,["$$slots","$$events","$$legacy","mesh","physicsShape"]);Te(n,ge({createMeshFunction:he,get physicsShape(){return p()}},()=>t,{get mesh(){return f()},set mesh(h){f(h)}})),ye()}Q.__docgen={data:[{name:"options",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"{ arc?: number | undefined; backUVs?: Vector4 | undefined; cap?: number | undefined; diameter?: number | undefined; diameterBottom?: number | undefined; diameterTop?: number | undefined; ... 9 more ...; updatable?: boolean | undefined; }"},static:!1,readonly:!1},{name:"scene",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"Scene"},static:!1,readonly:!1},{name:"children",visibility:"public",keywords:[],kind:"let",type:{kind:"function",text:"Snippet<[]>"},static:!1,readonly:!1},{name:"mesh",visibility:"public",description:"if you want to use a mesh api, bind it",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"Mesh"},static:!1,readonly:!1,defaultValue:"..."},{name:"physics",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"boolean",text:"boolean"},static:!1,readonly:!1},{name:"physicsShape",visibility:"public",keywords:[],kind:"let",type:{kind:"union",type:[{kind:"const",type:"number",value:0,text:"PhysicsShapeType.SPHERE"},{kind:"const",type:"number",value:1,text:"PhysicsShapeType.CAPSULE"},{kind:"const",type:"number",value:2,text:"PhysicsShapeType.CYLINDER"},{kind:"const",type:"number",value:3,text:"PhysicsShapeType.BOX"},{kind:"const",type:"number",value:4,text:"PhysicsShapeType.CONVEX_HULL"},{kind:"const",type:"number",value:5,text:"PhysicsShapeType.CONTAINER"},{kind:"const",type:"number",value:6,text:"PhysicsShapeType.MESH"},{kind:"const",type:"number",value:7,text:"PhysicsShapeType.HEIGHTFIELD"},{kind:"type",type:"object",text:"PhysicsShape"}],text:"PhysicsShapeType.SPHERE | PhysicsShapeType.CAPSULE | PhysicsShapeType.CYLINDER | PhysicsShapeType.BOX | PhysicsShapeType.CONVEX_HULL | PhysicsShapeType.CONTAINER | PhysicsShapeType.MESH | PhysicsShapeType.HEIGHTFIELD | PhysicsShape"},static:!1,readonly:!1,defaultValue:"PhysicsShapeType.CYLINDER"},{name:"physicsOptions",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"PhysicsAggregateParameters"},static:!1,readonly:!1},{name:"position",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"{ x: number; y: number; z: number; }"},static:!1,readonly:!1},{name:"rotation",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"{ x: number; y: number; z: number; }"},static:!1,readonly:!1},{name:"scaling",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"{ x: number; y: number; z: number; }"},static:!1,readonly:!1}],name:"Cylinder.svelte"};const Re={title:"mesh/Cylinder",tags:["autodocs"],component:Q},{Story:$e}=De();var He=Ce("<!> <!> <!>",1);function me(n,a){de(a,!1),Ve(),$e(n,{name:"Docs",args:{options:{arc:void 0,backUVs:{x:0,y:0,z:1,w:1},cap:void 0,diameter:4,diameterBottom:void 0,diameterTop:void 0,enclose:void 0,faceColors:[{r:1,g:1,b:1,a:1}],faceUV:[{x:0,y:0,z:1,w:1}],frontUVs:{x:0,y:0,z:1,w:1},hasRings:void 0,height:4,sideOrientation:void 0,subdivisions:void 0,tessellation:void 0,updatable:void 0},position:{x:0,y:0,z:0},rotation:{x:0,y:0,z:0},scaling:{x:1,y:1,z:1}},children:(p,t=Ue)=>{Ae(p,{style:"width: 100%;",children:(h,y)=>{Ne(h,{children:(C,N)=>{Oe(C,{children:(T,W)=>{var i=He(),s=ve(i);Ie(s,{position:new E(0,5,-10)});var B=pe(s,2);Me(B,{direction:new E(0,1,0),intensity:.7});var J=pe(B,2),I=ze(()=>{var m,r,b,l,g,v,Y,M,L,R,Z,c,o,O;return{...t().options,faceUV:(r=(m=t().options)==null?void 0:m.faceUV)==null?void 0:r.map(k=>new G(k.x,k.y,k.z,k.w)),faceColors:(l=(b=t().options)==null?void 0:b.faceColors)==null?void 0:l.map(k=>new ue(k.r,k.g,k.b,k.a)),frontUVs:(g=t().options)!=null&&g.frontUVs?new G((v=t().options)==null?void 0:v.frontUVs.x,(Y=t().options)==null?void 0:Y.frontUVs.y,(M=t().options)==null?void 0:M.frontUVs.z,(L=t().options)==null?void 0:L.frontUVs.w):void 0,backUVs:(R=t().options)!=null&&R.backUVs?new G((Z=t().options)==null?void 0:Z.backUVs.x,(c=t().options)==null?void 0:c.backUVs.y,(o=t().options)==null?void 0:o.backUVs.z,(O=t().options)==null?void 0:O.backUVs.w):void 0}});Q(J,{get options(){return Se(I)},get position(){return t().position},get rotation(){return t().rotation},get scaling(){return t().scaling}}),we(T,i)},$$slots:{default:!0}})},$$slots:{default:!0}})},$$slots:{default:!0}})},$$slots:{default:!0},parameters:{__svelteCsf:{rawCode:`<Canvas style="width: 100%;">
  <Engine>
    <Scene>
      <FreeCamera position={new Vector3(0, 5, -10)} />
      <HemisphericLight direction={new Vector3(0, 1, 0)} intensity={0.7} />
      <Cylinder
        options={{
          ...args.options,
          faceUV: args.options?.faceUV?.map((v) => new Vector4(v.x, v.y, v.z, v.w)),
          faceColors: args.options?.faceColors?.map((v) => new Color4(v.r, v.g, v.b, v.a)),
          frontUVs: args.options?.frontUVs
            ? new Vector4(
                args.options?.frontUVs.x,
                args.options?.frontUVs.y,
                args.options?.frontUVs.z,
                args.options?.frontUVs.w
              )
            : undefined,
          backUVs: args.options?.backUVs
            ? new Vector4(
                args.options?.backUVs.x,
                args.options?.backUVs.y,
                args.options?.backUVs.z,
                args.options?.backUVs.w
              )
            : undefined
        }}
        position={args.position}
        rotation={args.rotation}
        scaling={args.scaling}
      />
    </Scene>
  </Engine>
</Canvas>`}}}),ye()}me.__docgen={version:3,name:"Cylinder.stories.svelte",data:[],computed:[],methods:[],components:[],description:null,keywords:[],events:[],slots:[],refs:[]};const Fe=Le(me,Re),Ke=["Docs"],Qe=Fe.Docs;export{Qe as Docs,Ke as __namedExportsOrder,Re as default};
