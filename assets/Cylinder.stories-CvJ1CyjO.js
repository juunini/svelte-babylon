import{p as le,s as ke,r as ve,i as ge,a as we,t as Ce}from"./props-CDwtXEPn.js";import{p as pe,a as de,f as Se,s as ce,g as Ve,n as ze,d as Pe}from"./index-client-0IVJ1HVs.js";import{u as G,M as D,y as Ue,n as ue,m as X,V as _,z as Ee,w as ye,v as _e,l as Te,c as Ae,d as Ie,C as De,E as Le,S as Me,A as Re,H as Ne}from"./create-runtime-stories-DlYX6Gso.js";import"./iframe-DXvAOt9X.js";import"../sb-preview/runtime.js";import"./index-D-8MO0q_.js";import"./index-BHYIh-Xd.js";import"./_commonjsHelpers-Cpj98o6Y.js";function fe(s){const a=s.height||2;let f=s.diameterTop===0?0:s.diameterTop||s.diameter||1,c=s.diameterBottom===0?0:s.diameterBottom||s.diameter||1;f=f||1e-5,c=c||1e-5;const t=(s.tessellation||24)|0,h=(s.subdivisions||1)|0,d=!!s.hasRings,C=!!s.enclose,L=s.cap===0?0:s.cap||D.CAP_ALL,T=s.arc&&(s.arc<=0||s.arc>1)?1:s.arc||1,W=s.sideOrientation===0?0:s.sideOrientation||G.DEFAULTSIDE,i=s.faceUV||new Array(3),n=s.faceColors,B=T!==1&&C?2:0,J=d?h:1,R=2+(1+B)*J;let m;for(m=0;m<R;m++)n&&n[m]===void 0&&(n[m]=new ue(1,1,1,1));for(m=0;m<R;m++)i&&i[m]===void 0&&(i[m]=new X(0,0,1,1));const r=[],b=[],y=[],k=[],S=[],Y=Math.PI*2*T/t;let N,A,O;const Z=(c-f)/2/a,l=_.Zero(),o=_.Zero(),M=_.Zero(),v=_.Zero(),p=_.Zero(),ee=Ee.Y;let u,x,j,te=1,e=1,F=0,V=0;for(u=0;u<=h;u++)for(A=u/h,O=(A*(f-c)+c)/2,te=d&&u!==0&&u!==h?2:1,j=0;j<te;j++){for(d&&(e+=j),C&&(e+=2*j),x=0;x<=t;x++)N=x*Y,l.x=Math.cos(-N)*O,l.y=-a/2+A*a,l.z=Math.sin(-N)*O,f===0&&u===h?(o.x=y[y.length-(t+1)*3],o.y=y[y.length-(t+1)*3+1],o.z=y[y.length-(t+1)*3+2]):(o.x=l.x,o.z=l.z,o.y=Math.sqrt(o.x*o.x+o.z*o.z)*Z,o.normalize()),x===0&&(M.copyFrom(l),v.copyFrom(o)),b.push(l.x,l.y,l.z),y.push(o.x,o.y,o.z),d?V=F!==e?i[e].y:i[e].w:V=i[e].y+(i[e].w-i[e].y)*A,k.push(i[e].x+(i[e].z-i[e].x)*x/t,V),n&&S.push(n[e].r,n[e].g,n[e].b,n[e].a);T!==1&&C&&(b.push(l.x,l.y,l.z),b.push(0,l.y,0),b.push(0,l.y,0),b.push(M.x,M.y,M.z),_.CrossToRef(ee,o,p),p.normalize(),y.push(p.x,p.y,p.z,p.x,p.y,p.z),_.CrossToRef(v,ee,p),p.normalize(),y.push(p.x,p.y,p.z,p.x,p.y,p.z),d?V=F!==e?i[e+1].y:i[e+1].w:V=i[e+1].y+(i[e+1].w-i[e+1].y)*A,k.push(i[e+1].x,V),k.push(i[e+1].z,V),d?V=F!==e?i[e+2].y:i[e+2].w:V=i[e+2].y+(i[e+2].w-i[e+2].y)*A,k.push(i[e+2].x,V),k.push(i[e+2].z,V),n&&(S.push(n[e+1].r,n[e+1].g,n[e+1].b,n[e+1].a),S.push(n[e+1].r,n[e+1].g,n[e+1].b,n[e+1].a),S.push(n[e+2].r,n[e+2].g,n[e+2].b,n[e+2].a),S.push(n[e+2].r,n[e+2].g,n[e+2].b,n[e+2].a))),F!==e&&(F=e)}const q=T!==1&&C?t+4:t;for(u=0,e=0;e<h;e++){let g=0,z=0,P=0,I=0;for(x=0;x<t;x++)g=u*(q+1)+x,z=(u+1)*(q+1)+x,P=u*(q+1)+(x+1),I=(u+1)*(q+1)+(x+1),r.push(g,z,P),r.push(I,P,z);T!==1&&C&&(r.push(g+2,z+2,P+2),r.push(I+2,P+2,z+2),r.push(g+4,z+4,P+4),r.push(I+4,P+4,z+4)),u=d?u+2:u+1}const ne=g=>{const z=g?f/2:c/2;if(z===0)return;let P,I,U;const w=g?i[R-1]:i[0];let E=null;n&&(E=g?n[R-1]:n[0]);const $=b.length/3,se=g?a/2:-a/2,K=new _(0,se,0);b.push(K.x,K.y,K.z),y.push(0,g?1:-1,0);const be=w.y+(w.w-w.y)*.5;k.push(w.x+(w.z-w.x)*.5,be),E&&S.push(E.r,E.g,E.b,E.a);const ie=new ye(.5,.5);for(U=0;U<=t;U++){P=Math.PI*2*U*T/t;const ae=Math.cos(-P),oe=Math.sin(-P);I=new _(ae*z,se,oe*z);const re=new ye(ae*ie.x+.5,oe*ie.y+.5);b.push(I.x,I.y,I.z),y.push(0,g?1:-1,0);const xe=w.y+(w.w-w.y)*re.y;k.push(w.x+(w.z-w.x)*re.x,xe),E&&S.push(E.r,E.g,E.b,E.a)}for(U=0;U<t;U++)g?(r.push($),r.push($+(U+2)),r.push($+(U+1))):(r.push($),r.push($+(U+1)),r.push($+(U+2)))};(L===D.CAP_START||L===D.CAP_ALL)&&ne(!1),(L===D.CAP_END||L===D.CAP_ALL)&&ne(!0),G._ComputeSides(W,b,r,y,k,s.frontUVs,s.backUVs);const H=new G;return H.indices=r,H.positions=b,H.normals=y,H.uvs=k,n&&(H.colors=S),H}function he(s,a={},f){const c=new D(s,f);return a.sideOrientation=D._GetDefaultSideOrientation(a.sideOrientation),c._originalBuilderSideOrientation=a.sideOrientation,fe(a).applyToMesh(c,a.updatable),c}G.CreateCylinder=fe;D.CreateCylinder=(s,a,f,c,t,h,d,C,L)=>((d===void 0||!(d instanceof Ue))&&(d!==void 0&&(L=C||D.DEFAULTSIDE,C=d),d=h,h=1),he(s,{height:a,diameterTop:f,diameterBottom:c,tessellation:t,subdivisions:h,sideOrientation:L,updatable:C},d));function Q(s,a){pe(a,!0);let f=le(a,"mesh",15),c=le(a,"physicsShape",19,()=>_e.CYLINDER),t=ve(a,["$$slots","$$events","$$legacy","mesh","physicsShape"]);Te(s,ke({createMeshFunction:he,get physicsShape(){return c()}},()=>t,{get mesh(){return f()},set mesh(h){f(h)}})),de()}Q.__docgen={data:[{name:"options",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"{ arc?: number | undefined; backUVs?: Vector4 | undefined; cap?: number | undefined; diameter?: number | undefined; diameterBottom?: number | undefined; diameterTop?: number | undefined; ... 9 more ...; updatable?: boolean | undefined; }"},static:!1,readonly:!1},{name:"scene",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"Scene"},static:!1,readonly:!1},{name:"children",visibility:"public",keywords:[],kind:"let",type:{kind:"function",text:"Snippet<[]>"},static:!1,readonly:!1},{name:"mesh",visibility:"public",description:"if you want to use a mesh api, bind it",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"Mesh"},static:!1,readonly:!1,defaultValue:"..."},{name:"physics",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"boolean",text:"boolean"},static:!1,readonly:!1},{name:"physicsShape",visibility:"public",keywords:[],kind:"let",type:{kind:"union",type:[{kind:"const",type:"number",value:0,text:"PhysicsShapeType.SPHERE"},{kind:"const",type:"number",value:1,text:"PhysicsShapeType.CAPSULE"},{kind:"const",type:"number",value:2,text:"PhysicsShapeType.CYLINDER"},{kind:"const",type:"number",value:3,text:"PhysicsShapeType.BOX"},{kind:"const",type:"number",value:4,text:"PhysicsShapeType.CONVEX_HULL"},{kind:"const",type:"number",value:5,text:"PhysicsShapeType.CONTAINER"},{kind:"const",type:"number",value:6,text:"PhysicsShapeType.MESH"},{kind:"const",type:"number",value:7,text:"PhysicsShapeType.HEIGHTFIELD"},{kind:"type",type:"object",text:"PhysicsShape"}],text:"PhysicsShapeType.SPHERE | PhysicsShapeType.CAPSULE | PhysicsShapeType.CYLINDER | PhysicsShapeType.BOX | PhysicsShapeType.CONVEX_HULL | PhysicsShapeType.CONTAINER | PhysicsShapeType.MESH | PhysicsShapeType.HEIGHTFIELD | PhysicsShape"},static:!1,readonly:!1,defaultValue:"PhysicsShapeType.CYLINDER"},{name:"physicsOptions",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"PhysicsAggregateParameters"},static:!1,readonly:!1},{name:"position",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"{ x: number; y: number; z: number; }"},static:!1,readonly:!1},{name:"rotation",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"{ x: number; y: number; z: number; }"},static:!1,readonly:!1},{name:"scaling",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"{ x: number; y: number; z: number; }"},static:!1,readonly:!1},{name:"force",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"{ x: number; y: number; z: number; }"},static:!1,readonly:!1},{name:"impulse",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"{ x: number; y: number; z: number; }"},static:!1,readonly:!1},{name:"collideAgainstForce",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"{ x: number; y: number; z: number; }"},static:!1,readonly:!1},{name:"collideAgainstImpulse",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"{ x: number; y: number; z: number; }"},static:!1,readonly:!1},{name:"receiveShadows",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"boolean",text:"boolean"},static:!1,readonly:!1},{name:"shadowEnabled",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"boolean",text:"boolean"},static:!1,readonly:!1},{name:"shadowGroup",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"array",text:"string[]"},static:!1,readonly:!1},{name:"onCollision",visibility:"public",keywords:[],kind:"let",type:{kind:"function",text:"(eventData: IPhysicsCollisionEvent, eventState: EventState) => void"},static:!1,readonly:!1},{name:"onCollisionOnce",visibility:"public",keywords:[],kind:"let",type:{kind:"function",text:"(eventData: IPhysicsCollisionEvent, eventState: EventState) => void"},static:!1,readonly:!1}],name:"Cylinder.svelte"};const Oe={title:"mesh/Cylinder",tags:["autodocs"],component:Q},{Story:He}=Ie();var $e=Ce("<!> <!> <!>",1);function me(s,a){pe(a,!1),ge(),He(s,{name:"Docs",args:{options:{arc:void 0,backUVs:{x:0,y:0,z:1,w:1},cap:void 0,diameter:4,diameterBottom:void 0,diameterTop:void 0,enclose:void 0,faceColors:[{r:1,g:1,b:1,a:1}],faceUV:[{x:0,y:0,z:1,w:1}],frontUVs:{x:0,y:0,z:1,w:1},hasRings:void 0,height:4,sideOrientation:void 0,subdivisions:void 0,tessellation:void 0,updatable:void 0},position:{x:0,y:0,z:0},rotation:{x:0,y:0,z:0},scaling:{x:1,y:1,z:1}},parameters:{docs:{canvas:{sourceState:"shown"},source:{code:`<Canvas style="width: 100%;">
  <Engine>
    <Scene physics={false}>
      <ArcRotateCamera alpha={Math.PI / 2} beta={Math.PI / 2} radius={10} />
      <HemisphericLight direction={new Vector3(0, 1, 0)} intensity={0.7} />
      <Cylinder
        options={{ diameter: 4, height: 4 }}
        position={{ x: 0, y: 0, z: 0 }}
        rotation={{ x: 0, y: 0, z: 0 }}
        scaling={{ x: 1, y: 1, z: 1 }}
      />
    </Scene>
  </Engine>
</Canvas>`}},__svelteCsf:{rawCode:`<Canvas style="width: 100%;">
  <Engine>
    <Scene physics={false}>
      <ArcRotateCamera alpha={Math.PI / 2} beta={Math.PI / 2} radius={10} />
      <HemisphericLight direction={new Vector3(0, 1, 0)} intensity={0.7} />
      <Cylinder
        options={{
          ...args.options,
          faceUV: args.options?.faceUV?.map((v) => new Vector4(v.x, v.y, v.z, v.w)),
          faceColors: args.options?.faceColors?.map((v) => new Color4(v.r, v.g, v.b, v.a)),
          frontUVs: args.options?.frontUVs
            ? new Vector4(
                args.options?.frontUVs.x,
                args.options?.frontUVs.y,
                args.options?.frontUVs.z,
                args.options?.frontUVs.w
              )
            : undefined,
          backUVs: args.options?.backUVs
            ? new Vector4(
                args.options?.backUVs.x,
                args.options?.backUVs.y,
                args.options?.backUVs.z,
                args.options?.backUVs.w
              )
            : undefined
        }}
        position={args.position}
        rotation={args.rotation}
        scaling={args.scaling}
      />
    </Scene>
  </Engine>
</Canvas>`}},children:(c,t=ze)=>{De(c,{style:"width: 100%;",children:(h,d)=>{Le(h,{children:(C,L)=>{Me(C,{physics:!1,children:(T,W)=>{var i=$e(),n=Se(i);Re(n,{alpha:Math.PI/2,beta:Math.PI/2,radius:10});var B=ce(n,2);Ne(B,{direction:new _(0,1,0),intensity:.7});var J=ce(B,2),R=Pe(()=>{var m,r,b,y,k,S,Y,N,A,O,Z,l,o,M;return{...t().options,faceUV:(r=(m=t().options)==null?void 0:m.faceUV)==null?void 0:r.map(v=>new X(v.x,v.y,v.z,v.w)),faceColors:(y=(b=t().options)==null?void 0:b.faceColors)==null?void 0:y.map(v=>new ue(v.r,v.g,v.b,v.a)),frontUVs:(k=t().options)!=null&&k.frontUVs?new X((S=t().options)==null?void 0:S.frontUVs.x,(Y=t().options)==null?void 0:Y.frontUVs.y,(N=t().options)==null?void 0:N.frontUVs.z,(A=t().options)==null?void 0:A.frontUVs.w):void 0,backUVs:(O=t().options)!=null&&O.backUVs?new X((Z=t().options)==null?void 0:Z.backUVs.x,(l=t().options)==null?void 0:l.backUVs.y,(o=t().options)==null?void 0:o.backUVs.z,(M=t().options)==null?void 0:M.backUVs.w):void 0}});Q(J,{get options(){return Ve(R)},get position(){return t().position},get rotation(){return t().rotation},get scaling(){return t().scaling}}),we(T,i)},$$slots:{default:!0}})},$$slots:{default:!0}})},$$slots:{default:!0}})},$$slots:{default:!0}}),de()}me.__docgen={version:3,name:"Cylinder.stories.svelte",data:[],computed:[],methods:[],components:[],description:null,keywords:[],events:[],slots:[],refs:[]};const je=Ae(me,Oe),Ke=["Docs"],Qe=je.Docs;export{Qe as Docs,Ke as __namedExportsOrder,Oe as default};
