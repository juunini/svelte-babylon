import{p as M,i as H,a as B,t as E}from"./props-BRt4u2O_.js";import{p as U,f as D,b as X,c as S}from"./index-client-atPt8Ppi.js";import{e as P,o as q,V as v,M as C,p as I,h as d,f as W,i as J,j as K,k as N,F as Q,H as $,g as ee}from"./create-runtime-stories-C5aqBmYi.js";import"./iframe-BEUO-_wG.js";import"../sb-preview/runtime.js";import"./index-D-8MO0q_.js";import"./index-BHYIh-Xd.js";import"./_commonjsHelpers-Cpj98o6Y.js";function O(e,t){let s=M(t,"mesh",15);P(e,{createMeshFunction:q,get options(){return t.options},get scene(){return t.scene},get position(){return t.position},get lookAt(){return t.lookAt},get mesh(){return s()},set mesh(o){s(o)}})}O.__docgen={data:[{name:"mesh",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"GroundMesh"},static:!1,readonly:!1,defaultValue:"..."},{name:"options",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"{ width?: number | undefined; height?: number | undefined; subdivisions?: number | undefined; subdivisionsX?: number | undefined; subdivisionsY?: number | undefined; updatable?: boolean | undefined; }"},static:!1,readonly:!1},{name:"scene",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"Scene"},static:!1,readonly:!1},{name:"useParentScene",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"boolean",text:"boolean"},static:!1,readonly:!1},{name:"position",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"Vector3"},static:!1,readonly:!1},{name:"lookAt",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"{ targetPoint: Vector3; yawCor?: number | undefined; pitchCor?: number | undefined; rollCor?: number | undefined; }"},static:!1,readonly:!1}],name:"Ground.svelte"};function Y(e){const t=(e.segments||32)|0,s=e.diameterX||e.diameter||1,o=e.diameterY||e.diameter||1,c=e.diameterZ||e.diameter||1,f=e.arc&&(e.arc<=0||e.arc>1)?1:e.arc||1,h=e.slice&&e.slice<=0?1:e.slice||1,_=e.sideOrientation===0?0:e.sideOrientation||v.DEFAULTSIDE,g=!!e.dedupTopBottomIndices,k=new d(s/2,o/2,c/2),u=2+t,a=2*u,n=[],r=[],p=[],m=[];for(let y=0;y<=u;y++){const x=y/u,R=x*Math.PI*h;for(let b=0;b<=a;b++){const i=b/a,T=i*Math.PI*2*f,A=I.RotationZ(-R),L=I.RotationY(T),z=d.TransformCoordinates(d.Up(),A),V=d.TransformCoordinates(z,L),j=V.multiply(k),w=V.divide(k).normalize();r.push(j.x,j.y,j.z),p.push(w.x,w.y,w.z),m.push(i,x)}if(y>0){const b=r.length/3;for(let i=b-2*(a+1);i+a+2<b;i++)g?(y>1&&(n.push(i),n.push(i+1),n.push(i+a+1)),(y<u||h<1)&&(n.push(i+a+1),n.push(i+1),n.push(i+a+2))):(n.push(i),n.push(i+1),n.push(i+a+1),n.push(i+a+1),n.push(i+1),n.push(i+a+2))}}v._ComputeSides(_,r,n,p,m,e.frontUVs,e.backUVs);const l=new v;return l.indices=n,l.positions=r,l.normals=p,l.uvs=m,l}function Z(e,t={},s=null){const o=new C(e,s);return t.sideOrientation=C._GetDefaultSideOrientation(t.sideOrientation),o._originalBuilderSideOrientation=t.sideOrientation,Y(t).applyToMesh(o,t.updatable),o}v.CreateSphere=Y;C.CreateSphere=(e,t,s,o,c,f)=>Z(e,{segments:t,diameterX:s,diameterY:s,diameterZ:s,sideOrientation:f,updatable:c},o);function F(e,t){let s=M(t,"mesh",15);P(e,{createMeshFunction:Z,get options(){return t.options},get scene(){return t.scene},get position(){return t.position},get lookAt(){return t.lookAt},get mesh(){return s()},set mesh(o){s(o)}})}F.__docgen={data:[{name:"options",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"{ arc?: number | undefined; backUVs?: Vector4 | undefined; diameter?: number | undefined; diameterX?: number | undefined; diameterY?: number | undefined; diameterZ?: number | undefined; ... 4 more ...; updatable?: boolean | undefined; }"},static:!1,readonly:!1},{name:"scene",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"Scene"},static:!1,readonly:!1},{name:"mesh",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"Mesh"},static:!1,readonly:!1,defaultValue:"..."},{name:"useParentScene",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"boolean",text:"boolean"},static:!1,readonly:!1},{name:"position",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"Vector3"},static:!1,readonly:!1},{name:"lookAt",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"{ targetPoint: Vector3; yawCor?: number | undefined; pitchCor?: number | undefined; rollCor?: number | undefined; }"},static:!1,readonly:!1}],name:"Sphere.svelte"};const te={title:"Introduce",tags:["autodocs"]},{Story:ne}=ee();var ie=E("<!> <!> <!> <!>",1),se=E(`<!> <h1>@juunini/svelte-babylonjs</h1> <h2>Caution</h2> <blockquote><p>‚ùó This is WIP and not ready for production use.</p></blockquote> <h2>Introduction</h2> Easily create 3D scenes with Babylon.js in Svelte. <h2>Usage</h2> <p>Click under <code>Show code</code> button or to see category</p> <h2>Installation</h2> <code><pre>
npm install @juunini/svelte-babylonjs
yarn add @juunini/svelte-babylonjs
pnpm add @juunini/svelte-babylonjs
bun add @juunini/svelte-babylonjs
  </pre></code> <h2>License</h2> MIT`,1);function G(e,t){U(t,!1),H();var s=se(),o=D(s);ne(o,{name:"Docs",parameters:{docs:{source:{language:"html",code:`<script lang="ts">
  import { Vector3 } from '@babylonjs/core/Maths/math.vector';

  import Canvas from '@juunini/svelte-babylonjs/Canvas.svelte';
  import BabylonEngine from '@juunini/svelte-babylonjs/engine/Engine.svelte';
  import BabylonScene from '@juunini/svelte-babylonjs/Scene.svelte';
  import BabylonFreeCamera from '@juunini/svelte-babylonjs/camera/FreeCamera.svelte';
  import BabylonGround from '@juunini/svelte-babylonjs/mesh/Ground.svelte';
  import BabylonHemisphericLight from '@juunini/svelte-babylonjs/light/HemisphericLight.svelte';
  import BabylonSphere from '@juunini/svelte-babylonjs/mesh/Sphere.svelte';
<\/script>

<Canvas style="width: 100%;">
  <BabylonEngine>
    <BabylonScene>
      <BabylonFreeCamera position={new Vector3(0, 5, -10)} />
      <BabylonHemisphericLight direction={new Vector3(0, 1, 0)} intensity={0.7} />
      <BabylonGround options={{ width: 6, height: 6 }} />
      <BabylonSphere options={{ diameter: 2, segments: 32 }} position={new Vector3(0, 1, 0)} />
    </BabylonScene>
  </BabylonEngine>
</Canvas>`}},__svelteCsf:{rawCode:`<Canvas style="width: 100%;">
  <Engine>
    <Scene>
      <FreeCamera position={new Vector3(0, 5, -10)} />
      <HemisphericLight direction={new Vector3(0, 1, 0)} intensity={0.7} />
      <Ground options={{ width: 6, height: 6 }} />
      <Sphere options={{ diameter: 2, segments: 32 }} position={new Vector3(0, 1, 0)} />
    </Scene>
  </Engine>
</Canvas>`}},children:(c,f)=>{J(c,{style:"width: 100%;",children:(h,_)=>{K(h,{children:(g,k)=>{N(g,{children:(u,a)=>{var n=ie(),r=D(n);Q(r,{position:new d(0,5,-10)});var p=S(r,2);$(p,{direction:new d(0,1,0),intensity:.7});var m=S(p,2);O(m,{options:{width:6,height:6}});var l=S(m,2);F(l,{options:{diameter:2,segments:32},position:new d(0,1,0)}),B(u,n)},$$slots:{default:!0}})},$$slots:{default:!0}})},$$slots:{default:!0}})},$$slots:{default:!0}}),B(e,s),X()}G.__docgen={version:3,name:"Introduce.stories.svelte",data:[],computed:[],methods:[],components:[],description:null,keywords:[],events:[],slots:[],refs:[]};const oe=W(G,te),ye=["Docs"],be=oe.Docs;export{be as Docs,ye as __namedExportsOrder,te as default};
