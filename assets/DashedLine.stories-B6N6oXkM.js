const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./color.vertex-C6qxQly1.js","./create-runtime-stories-BkvPK9tB.js","./props-D_CwaEcb.js","./index-client-a4XWVA08.js","./iframe-DOBaK8HO.js","./index-D-8MO0q_.js","./index-BHYIh-Xd.js","./_commonjsHelpers-Cpj98o6Y.js","./vertexColorMixing-gY0hqIyB.js","./color.fragment-BDtywhH2.js","./fogFragment-B95KU1bf.js","./color.vertex-D6vLhBMM.js","./vertexColorMixing-CY5K7BmK.js","./color.fragment-BN4sNh-W.js","./fogFragment-ETHLAgz7.js"])))=>i.map(i=>d[i]);
import{p as ee,s as te,r as se,i as re,a as ie,t as ne}from"./props-D_CwaEcb.js";import{p as ae,a as oe,f as he,b as ce,n as fe,c as W,d as ue}from"./index-client-a4XWVA08.js";import{M as S,w as le,T as w,i as R,e as A,x as de,q as P,b as q,D as _e,y as $,z as pe,G as ye,J as ge,K as xe,N as me,r as Ae,O as Me,Q as ve,U as Se,W as be,X as Ie,Y as Be,Z as C,u as G,g as V,j as F,c as Te,V as T,d as Oe,$ as we,a0 as H,E as K,a1 as De,a2 as L,f as E,a3 as Pe,k as Ve,l as Ee,m as Ce,n as Le,o as ke,p as Re,F as Fe,H as ze}from"./create-runtime-stories-BkvPK9tB.js";import{_ as D}from"./iframe-DOBaK8HO.js";import"./index-D-8MO0q_.js";import"./index-BHYIh-Xd.js";import"./_commonjsHelpers-Cpj98o6Y.js";import"../sb-preview/runtime.js";S._instancedMeshFactory=(u,e)=>{const t=new z(u,e);if(e.instancedBuffers){t.instancedBuffers={};for(const s in e.instancedBuffers)t.instancedBuffers[s]=e.instancedBuffers[s]}return t};class z extends le{constructor(e,t){super(e,t.getScene()),this._indexInSourceMeshInstanceArray=-1,this._distanceToCamera=0,t.addInstance(this),this._sourceMesh=t,this._unIndexed=t._unIndexed,this.position.copyFrom(t.position),this.rotation.copyFrom(t.rotation),this.scaling.copyFrom(t.scaling),t.rotationQuaternion&&(this.rotationQuaternion=t.rotationQuaternion.clone()),this.animations=t.animations.slice();for(const s of t.getAnimationRanges())s!=null&&this.createAnimationRange(s.name,s.from,s.to);this.infiniteDistance=t.infiniteDistance,this.setPivotMatrix(t.getPivotMatrix()),this.refreshBoundingInfo(!0,!0),this._syncSubMeshes()}getClassName(){return"InstancedMesh"}get lightSources(){return this._sourceMesh._lightSources}_resyncLightSources(){}_resyncLightSource(){}_removeLightSource(){}get receiveShadows(){return this._sourceMesh.receiveShadows}set receiveShadows(e){var t;((t=this._sourceMesh)==null?void 0:t.receiveShadows)!==e&&w.Warn("Setting receiveShadows on an instanced mesh has no effect")}get material(){return this._sourceMesh.material}set material(e){var t;((t=this._sourceMesh)==null?void 0:t.material)!==e&&w.Warn("Setting material on an instanced mesh has no effect")}get visibility(){return this._sourceMesh.visibility}set visibility(e){var t;((t=this._sourceMesh)==null?void 0:t.visibility)!==e&&w.Warn("Setting visibility on an instanced mesh has no effect")}get skeleton(){return this._sourceMesh.skeleton}set skeleton(e){var t;((t=this._sourceMesh)==null?void 0:t.skeleton)!==e&&w.Warn("Setting skeleton on an instanced mesh has no effect")}get renderingGroupId(){return this._sourceMesh.renderingGroupId}set renderingGroupId(e){!this._sourceMesh||e===this._sourceMesh.renderingGroupId||R.Warn("Note - setting renderingGroupId of an instanced mesh has no effect on the scene")}getTotalVertices(){return this._sourceMesh?this._sourceMesh.getTotalVertices():0}getTotalIndices(){return this._sourceMesh.getTotalIndices()}get sourceMesh(){return this._sourceMesh}createInstance(e){return this._sourceMesh.createInstance(e)}isReady(e=!1){return this._sourceMesh.isReady(e,!0)}getVerticesData(e,t,s){return this._sourceMesh.getVerticesData(e,t,s)}copyVerticesData(e,t){this._sourceMesh.copyVerticesData(e,t)}setVerticesData(e,t,s,r){return this.sourceMesh&&this.sourceMesh.setVerticesData(e,t,s,r),this.sourceMesh}updateVerticesData(e,t,s,r){return this.sourceMesh&&this.sourceMesh.updateVerticesData(e,t,s,r),this.sourceMesh}setIndices(e,t=null){return this.sourceMesh&&this.sourceMesh.setIndices(e,t),this.sourceMesh}isVerticesDataPresent(e){return this._sourceMesh.isVerticesDataPresent(e)}getIndices(){return this._sourceMesh.getIndices()}get _positions(){return this._sourceMesh._positions}refreshBoundingInfo(e=!1,t=!1){if(this.hasBoundingInfo&&this.getBoundingInfo().isLocked)return this;let s;typeof e=="object"?s=e:s={applySkeleton:e,applyMorph:t};const r=this._sourceMesh.geometry?this._sourceMesh.geometry.boundingBias:null;return this._refreshBoundingInfo(this._sourceMesh._getData(s,null,A.PositionKind),r),this}_preActivate(){return this._currentLOD&&this._currentLOD._preActivate(),this}_activate(e,t){if(super._activate(e,t),this._sourceMesh.subMeshes||R.Warn("Instances should only be created for meshes with geometry."),this._currentLOD){if(this._currentLOD._getWorldMatrixDeterminant()>=0!=this._getWorldMatrixDeterminant()>=0)return this._internalAbstractMeshDataInfo._actAsRegularMesh=!0,!0;if(this._internalAbstractMeshDataInfo._actAsRegularMesh=!1,this._currentLOD._registerInstanceForRenderId(this,e),t){if(!this._currentLOD._internalAbstractMeshDataInfo._isActiveIntermediate)return this._currentLOD._internalAbstractMeshDataInfo._onlyForInstancesIntermediate=!0,!0}else if(!this._currentLOD._internalAbstractMeshDataInfo._isActive)return this._currentLOD._internalAbstractMeshDataInfo._onlyForInstances=!0,!0}return!1}_postActivate(){this._sourceMesh.edgesShareWithInstances&&this._sourceMesh._edgesRenderer&&this._sourceMesh._edgesRenderer.isEnabled&&this._sourceMesh._renderingGroup?(this._sourceMesh._renderingGroup._edgesRenderers.pushNoDuplicate(this._sourceMesh._edgesRenderer),this._sourceMesh._edgesRenderer.customInstances.push(this.getWorldMatrix())):this._edgesRenderer&&this._edgesRenderer.isEnabled&&this._sourceMesh._renderingGroup&&this._sourceMesh._renderingGroup._edgesRenderers.push(this._edgesRenderer)}getWorldMatrix(){if(this._currentLOD&&this._currentLOD.billboardMode!==de.BILLBOARDMODE_NONE&&this._currentLOD._masterMesh!==this){this._billboardWorldMatrix||(this._billboardWorldMatrix=new P);const e=this._currentLOD._masterMesh;return this._currentLOD._masterMesh=this,q.Vector3[7].copyFrom(this._currentLOD.position),this._currentLOD.position.set(0,0,0),this._billboardWorldMatrix.copyFrom(this._currentLOD.computeWorldMatrix(!0)),this._currentLOD.position.copyFrom(q.Vector3[7]),this._currentLOD._masterMesh=e,this._billboardWorldMatrix}return super.getWorldMatrix()}get isAnInstance(){return!0}getLOD(e){if(!e)return this;const t=this.sourceMesh.getLODLevels();if(!t||t.length===0)this._currentLOD=this.sourceMesh;else{const s=this.getBoundingInfo();this._currentLOD=this.sourceMesh.getLOD(e,s.boundingSphere)}return this._currentLOD}_preActivateForIntermediateRendering(e){return this.sourceMesh._preActivateForIntermediateRendering(e)}_syncSubMeshes(){if(this.releaseSubMeshes(),this._sourceMesh.subMeshes)for(let e=0;e<this._sourceMesh.subMeshes.length;e++)this._sourceMesh.subMeshes[e].clone(this,this._sourceMesh);return this}_generatePointsArray(){return this._sourceMesh._generatePointsArray()}_updateBoundingInfo(){return this.hasBoundingInfo?this.getBoundingInfo().update(this.worldMatrixFromCache):this.buildBoundingInfo(this.absolutePosition,this.absolutePosition,this.worldMatrixFromCache),this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache),this}clone(e,t=null,s,r){const i=(r||this._sourceMesh).createInstance(e);if(_e.DeepCopy(this,i,["name","subMeshes","uniqueId","parent","lightSources","receiveShadows","material","visibility","skeleton","sourceMesh","isAnInstance","facetNb","isFacetDataEnabled","isBlocked","useBones","hasInstances","collider","edgesRenderer","forward","up","right","absolutePosition","absoluteScaling","absoluteRotationQuaternion","isWorldMatrixFrozen","nonUniformScaling","behaviors","worldMatrixFromCache","hasThinInstances","hasBoundingInfo"],[]),this.refreshBoundingInfo(),t&&(i.parent=t),!s)for(let o=0;o<this.getScene().meshes.length;o++){const n=this.getScene().meshes[o];n.parent===this&&n.clone(n.name,i)}return i.computeWorldMatrix(!0),this.onClonedObservable.notifyObservers(i),i}dispose(e,t=!1){this._sourceMesh.removeInstance(this),super.dispose(e,t)}_serializeAsParent(e){super._serializeAsParent(e),e.parentId=this._sourceMesh.uniqueId,e.parentInstanceIndex=this._indexInSourceMeshInstanceArray}instantiateHierarchy(e=null,t,s){const r=this.clone("Clone of "+(this.name||this.id),e||this.parent,!0,t&&t.newSourcedMesh);r&&s&&s(this,r);for(const i of this.getChildTransformNodes(!0))i.instantiateHierarchy(r,t,s);return r}}S.prototype.registerInstancedBuffer=function(u,e){var t,s;if((s=(t=this._userInstancedBuffersStorage)==null?void 0:t.vertexBuffers[u])==null||s.dispose(),!this.instancedBuffers){this.instancedBuffers={};for(const r of this.instances)r.instancedBuffers={}}this._userInstancedBuffersStorage||(this._userInstancedBuffersStorage={data:{},vertexBuffers:{},strides:{},sizes:{},vertexArrayObjects:this.getEngine().getCaps().vertexArrayObject?{}:void 0}),this.instancedBuffers[u]=null,this._userInstancedBuffersStorage.strides[u]=e,this._userInstancedBuffersStorage.sizes[u]=e*32,this._userInstancedBuffersStorage.data[u]=new Float32Array(this._userInstancedBuffersStorage.sizes[u]),this._userInstancedBuffersStorage.vertexBuffers[u]=new A(this.getEngine(),this._userInstancedBuffersStorage.data[u],u,!0,!1,e,!0);for(const r of this.instances)r.instancedBuffers[u]=null;this._invalidateInstanceVertexArrayObject(),this._markSubMeshesAsAttributesDirty()};S.prototype._processInstancedBuffers=function(u,e){const t=u?u.length:0;for(const s in this.instancedBuffers){let r=this._userInstancedBuffersStorage.sizes[s];const i=this._userInstancedBuffersStorage.strides[s],o=(t+1)*i;for(;r<o;)r*=2;this._userInstancedBuffersStorage.data[s].length!=r&&(this._userInstancedBuffersStorage.data[s]=new Float32Array(r),this._userInstancedBuffersStorage.sizes[s]=r,this._userInstancedBuffersStorage.vertexBuffers[s]&&(this._userInstancedBuffersStorage.vertexBuffers[s].dispose(),this._userInstancedBuffersStorage.vertexBuffers[s]=null));const n=this._userInstancedBuffersStorage.data[s];let c=0;if(e){const l=this.instancedBuffers[s];l.toArray?l.toArray(n,c):l.copyToArray?l.copyToArray(n,c):n[c]=l,c+=i}for(let l=0;l<t;l++){const h=u[l].instancedBuffers[s];h.toArray?h.toArray(n,c):h.copyToArray?h.copyToArray(n,c):n[c]=h,c+=i}this._userInstancedBuffersStorage.vertexBuffers[s]?this._userInstancedBuffersStorage.vertexBuffers[s].updateDirectly(n,0):(this._userInstancedBuffersStorage.vertexBuffers[s]=new A(this.getEngine(),this._userInstancedBuffersStorage.data[s],s,!0,!1,i,!0),this._invalidateInstanceVertexArrayObject())}};S.prototype._invalidateInstanceVertexArrayObject=function(){if(!(!this._userInstancedBuffersStorage||this._userInstancedBuffersStorage.vertexArrayObjects===void 0)){for(const u in this._userInstancedBuffersStorage.vertexArrayObjects)this.getEngine().releaseVertexArrayObject(this._userInstancedBuffersStorage.vertexArrayObjects[u]);this._userInstancedBuffersStorage.vertexArrayObjects={}}};S.prototype._disposeInstanceSpecificData=function(){for(this._instanceDataStorage.instancesBuffer&&(this._instanceDataStorage.instancesBuffer.dispose(),this._instanceDataStorage.instancesBuffer=null);this.instances.length;)this.instances[0].dispose();for(const u in this.instancedBuffers)this._userInstancedBuffersStorage.vertexBuffers[u]&&this._userInstancedBuffersStorage.vertexBuffers[u].dispose();this._invalidateInstanceVertexArrayObject(),this.instancedBuffers={}};$("BABYLON.InstancedMesh",z);const k={effect:null,subMesh:null};class I extends pe{constructor(e,t,s,r={},i=!0){super(e,t,i),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new P,this._cachedWorldViewProjectionMatrix=new P,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=s,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...r}}get shaderPath(){return this._shaderPath}set shaderPath(e){this._shaderPath=e}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(e){this._options.uniforms.indexOf(e)===-1&&this._options.uniforms.push(e)}setTexture(e,t){return this._options.samplers.indexOf(e)===-1&&this._options.samplers.push(e),this._textures[e]=t,this}removeTexture(e){delete this._textures[e]}setTextureArray(e,t){return this._options.samplers.indexOf(e)===-1&&this._options.samplers.push(e),this._checkUniform(e),this._textureArrays[e]=t,this}setExternalTexture(e,t){return this._options.externalTextures.indexOf(e)===-1&&this._options.externalTextures.push(e),this._externalTextures[e]=t,this}setFloat(e,t){return this._checkUniform(e),this._floats[e]=t,this}setInt(e,t){return this._checkUniform(e),this._ints[e]=t,this}setUInt(e,t){return this._checkUniform(e),this._uints[e]=t,this}setFloats(e,t){return this._checkUniform(e),this._floatsArrays[e]=t,this}setColor3(e,t){return this._checkUniform(e),this._colors3[e]=t,this}setColor3Array(e,t){return this._checkUniform(e),this._colors3Arrays[e]=t.reduce((s,r)=>(r.toArray(s,s.length),s),[]),this}setColor4(e,t){return this._checkUniform(e),this._colors4[e]=t,this}setColor4Array(e,t){return this._checkUniform(e),this._colors4Arrays[e]=t.reduce((s,r)=>(r.toArray(s,s.length),s),[]),this}setVector2(e,t){return this._checkUniform(e),this._vectors2[e]=t,this}setVector3(e,t){return this._checkUniform(e),this._vectors3[e]=t,this}setVector4(e,t){return this._checkUniform(e),this._vectors4[e]=t,this}setQuaternion(e,t){return this._checkUniform(e),this._quaternions[e]=t,this}setQuaternionArray(e,t){return this._checkUniform(e),this._quaternionsArrays[e]=t.reduce((s,r)=>(r.toArray(s,s.length),s),[]),this}setMatrix(e,t){return this._checkUniform(e),this._matrices[e]=t,this}setMatrices(e,t){this._checkUniform(e);const s=new Float32Array(t.length*16);for(let r=0;r<t.length;r++)t[r].copyToArray(s,r*16);return this._matrixArrays[e]=s,this}setMatrix3x3(e,t){return this._checkUniform(e),this._matrices3x3[e]=t,this}setMatrix2x2(e,t){return this._checkUniform(e),this._matrices2x2[e]=t,this}setArray2(e,t){return this._checkUniform(e),this._vectors2Arrays[e]=t,this}setArray3(e,t){return this._checkUniform(e),this._vectors3Arrays[e]=t,this}setArray4(e,t){return this._checkUniform(e),this._vectors4Arrays[e]=t,this}setUniformBuffer(e,t){return this._options.uniformBuffers.indexOf(e)===-1&&this._options.uniformBuffers.push(e),this._uniformBuffers[e]=t,this}setTextureSampler(e,t){return this._options.samplerObjects.indexOf(e)===-1&&this._options.samplerObjects.push(e),this._textureSamplers[e]=t,this}setStorageBuffer(e,t){return this._options.storageBuffers.indexOf(e)===-1&&this._options.storageBuffers.push(e),this._storageBuffers[e]=t,this}setDefine(e,t){const s=e.trimEnd()+" ",r=this.options.defines.findIndex(i=>i===e||i.startsWith(s));return r>=0&&this.options.defines.splice(r,1),(typeof t!="boolean"||t)&&this.options.defines.push(s+t),this}isReadyForSubMesh(e,t,s){return this.isReady(e,s,t)}isReady(e,t,s){const r=s&&this._storeEffectOnSubMeshes;if(this.isFrozen){const g=r?s._drawWrapper:this._drawWrapper;if(g.effect&&g._wasPreviouslyReady&&g._wasPreviouslyUsingInstances===t)return!0}const i=this.getScene(),o=i.getEngine(),n=[],c=[],l=new De;let f=this._shaderPath,h=this._options.uniforms,a=this._options.uniformBuffers,p=this._options.samplers;o.getCaps().multiview&&i.activeCamera&&i.activeCamera.outputRenderTarget&&i.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,n.push("#define MULTIVIEW"),h.indexOf("viewProjection")!==-1&&h.indexOf("viewProjectionR")===-1&&h.push("viewProjectionR"));for(let g=0;g<this._options.defines.length;g++){const O=this._options.defines[g].indexOf("#define")===0?this._options.defines[g]:`#define ${this._options.defines[g]}`;n.push(O)}for(let g=0;g<this._options.attributes.length;g++)c.push(this._options.attributes[g]);if(e&&e.isVerticesDataPresent(A.ColorKind)&&(c.indexOf(A.ColorKind)===-1&&c.push(A.ColorKind),n.push("#define VERTEXCOLOR")),t&&(n.push("#define INSTANCES"),ye(c,this._materialHelperNeedsPreviousMatrices),e!=null&&e.hasThinInstances&&(n.push("#define THIN_INSTANCES"),e&&e.isVerticesDataPresent(A.ColorInstanceKind)&&(c.push(A.ColorInstanceKind),n.push("#define INSTANCESCOLOR")))),e&&e.useBones&&e.computeBonesUsingShaders&&e.skeleton){c.push(A.MatricesIndicesKind),c.push(A.MatricesWeightsKind),e.numBoneInfluencers>4&&(c.push(A.MatricesIndicesExtraKind),c.push(A.MatricesWeightsExtraKind));const g=e.skeleton;n.push("#define NUM_BONE_INFLUENCERS "+e.numBoneInfluencers),l.addCPUSkinningFallback(0,e),g.isUsingTextureForMatrices?(n.push("#define BONETEXTURE"),h.indexOf("boneTextureWidth")===-1&&h.push("boneTextureWidth"),this._options.samplers.indexOf("boneSampler")===-1&&this._options.samplers.push("boneSampler")):(n.push("#define BonesPerMesh "+(g.bones.length+1)),h.indexOf("mBones")===-1&&h.push("mBones"))}else n.push("#define NUM_BONE_INFLUENCERS 0");let d=0;const y=e?e.morphTargetManager:null;if(y){const g=y.supportsUVs&&n.indexOf("#define UV1")!==-1,O=y.supportsUV2s&&n.indexOf("#define UV2")!==-1,N=y.supportsTangents&&n.indexOf("#define TANGENT")!==-1,j=y.supportsNormals&&n.indexOf("#define NORMAL")!==-1,Z=y.supportsPositions;d=y.numMaxInfluencers||y.numInfluencers,g&&n.push("#define MORPHTARGETS_UV"),O&&n.push("#define MORPHTARGETS_UV2"),N&&n.push("#define MORPHTARGETS_TANGENT"),j&&n.push("#define MORPHTARGETS_NORMAL"),Z&&n.push("#define MORPHTARGETS_POSITION"),d>0&&n.push("#define MORPHTARGETS"),y.isUsingTextureForTargets&&(n.push("#define MORPHTARGETS_TEXTURE"),h.indexOf("morphTargetTextureIndices")===-1&&h.push("morphTargetTextureIndices"),this._options.samplers.indexOf("morphTargets")===-1&&this._options.samplers.push("morphTargets")),n.push("#define NUM_MORPH_INFLUENCERS "+d);for(let B=0;B<d;B++)c.push(A.PositionKind+B),j&&c.push(A.NormalKind+B),N&&c.push(A.TangentKind+B),g&&c.push(A.UVKind+"_"+B);d>0&&(h=h.slice(),h.push("morphTargetInfluences"),h.push("morphTargetCount"),h.push("morphTargetTextureInfo"),h.push("morphTargetTextureIndices"))}else n.push("#define NUM_MORPH_INFLUENCERS 0");if(e){const g=e.bakedVertexAnimationManager;g&&g.isEnabled&&(n.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),h.indexOf("bakedVertexAnimationSettings")===-1&&h.push("bakedVertexAnimationSettings"),h.indexOf("bakedVertexAnimationTextureSizeInverted")===-1&&h.push("bakedVertexAnimationTextureSizeInverted"),h.indexOf("bakedVertexAnimationTime")===-1&&h.push("bakedVertexAnimationTime"),this._options.samplers.indexOf("bakedVertexAnimationTexture")===-1&&this._options.samplers.push("bakedVertexAnimationTexture")),ge(c,e,n)}for(const g in this._textures)if(!this._textures[g].isReady())return!1;e&&this._shouldTurnAlphaTestOn(e)&&n.push("#define ALPHATEST"),this._options.useClipPlane!==!1&&(xe(h),me(this,i,n)),i.fogEnabled&&(e!=null&&e.applyFog)&&i.fogMode!==Ae.FOGMODE_NONE&&(n.push("#define FOG"),h.indexOf("view")===-1&&h.push("view"),h.indexOf("vFogInfos")===-1&&h.push("vFogInfos"),h.indexOf("vFogColor")===-1&&h.push("vFogColor")),this._useLogarithmicDepth&&(n.push("#define LOGARITHMICDEPTH"),h.indexOf("logarithmicDepthConstant")===-1&&h.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(h=h.slice(),a=a.slice(),p=p.slice(),f=this.customShaderNameResolve(this.name,h,a,p,n,c));const _=r?s._getDrawWrapper(void 0,!0):this._drawWrapper,x=(_==null?void 0:_.effect)??null,M=(_==null?void 0:_.defines)??null,m=n.join(`
`);let v=x;return M!==m&&(v=o.createEffect(f,{attributes:c,uniformsNames:h,uniformBuffersNames:a,samplers:p,defines:m,fallbacks:l,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:d},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},o),r?s.setEffect(v,m,this._materialContext):_&&_.setEffect(v,m),this._onEffectCreatedObservable&&(k.effect=v,k.subMesh=s??(e==null?void 0:e.subMeshes[0])??null,this._onEffectCreatedObservable.notifyObservers(k))),_._wasPreviouslyUsingInstances=!!t,v!=null&&v.isReady()?(x!==v&&i.resetCachedMaterial(),_._wasPreviouslyReady=!0,!0):!1}bindOnlyWorldMatrix(e,t){const s=this.getScene(),r=t??this.getEffect();r&&(this._options.uniforms.indexOf("world")!==-1&&r.setMatrix("world",e),this._options.uniforms.indexOf("worldView")!==-1&&(e.multiplyToRef(s.getViewMatrix(),this._cachedWorldViewMatrix),r.setMatrix("worldView",this._cachedWorldViewMatrix)),this._options.uniforms.indexOf("worldViewProjection")!==-1&&(e.multiplyToRef(s.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),r.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),this._options.uniforms.indexOf("view")!==-1&&r.setMatrix("view",s.getViewMatrix()))}bindForSubMesh(e,t,s){var r;this.bind(e,t,(r=s._drawWrapperOverride)==null?void 0:r.effect,s)}bind(e,t,s,r){var h;const i=r&&this._storeEffectOnSubMeshes,o=s??(i?r.effect:this.getEffect());if(!o)return;const n=this.getScene();this._activeEffect=o,this.bindOnlyWorldMatrix(e,s);const c=this._options.uniformBuffers;let l=!1;if(o&&c&&c.length>0&&n.getEngine().supportsUniformBuffers)for(let a=0;a<c.length;++a)switch(c[a]){case"Mesh":t&&(t.getMeshUniformBuffer().bindToEffect(o,"Mesh"),t.transferToEffect(e));break;case"Scene":Me(o,n.getSceneUniformBuffer()),n.finalizeSceneUbo(),l=!0;break}const f=t&&i?this._mustRebind(n,o,r,t.visibility):n.getCachedMaterial()!==this;if(o&&f){!l&&this._options.uniforms.indexOf("view")!==-1&&o.setMatrix("view",n.getViewMatrix()),!l&&this._options.uniforms.indexOf("projection")!==-1&&o.setMatrix("projection",n.getProjectionMatrix()),!l&&this._options.uniforms.indexOf("viewProjection")!==-1&&(o.setMatrix("viewProjection",n.getTransformMatrix()),this._multiview&&o.setMatrix("viewProjectionR",n._transformMatrixR)),n.activeCamera&&this._options.uniforms.indexOf("cameraPosition")!==-1&&o.setVector3("cameraPosition",n.activeCamera.globalPosition),ve(t,o),Se(o,this,n),this._useLogarithmicDepth&&be(i?r.materialDefines:o.defines,o,n),t&&Ie(n,t,o);let a;for(a in this._textures)o.setTexture(a,this._textures[a]);for(a in this._textureArrays)o.setTextureArray(a,this._textureArrays[a]);for(a in this._ints)o.setInt(a,this._ints[a]);for(a in this._uints)o.setUInt(a,this._uints[a]);for(a in this._floats)o.setFloat(a,this._floats[a]);for(a in this._floatsArrays)o.setArray(a,this._floatsArrays[a]);for(a in this._colors3)o.setColor3(a,this._colors3[a]);for(a in this._colors3Arrays)o.setArray3(a,this._colors3Arrays[a]);for(a in this._colors4){const x=this._colors4[a];o.setFloat4(a,x.r,x.g,x.b,x.a)}for(a in this._colors4Arrays)o.setArray4(a,this._colors4Arrays[a]);for(a in this._vectors2)o.setVector2(a,this._vectors2[a]);for(a in this._vectors3)o.setVector3(a,this._vectors3[a]);for(a in this._vectors4)o.setVector4(a,this._vectors4[a]);for(a in this._quaternions)o.setQuaternion(a,this._quaternions[a]);for(a in this._matrices)o.setMatrix(a,this._matrices[a]);for(a in this._matrixArrays)o.setMatrices(a,this._matrixArrays[a]);for(a in this._matrices3x3)o.setMatrix3x3(a,this._matrices3x3[a]);for(a in this._matrices2x2)o.setMatrix2x2(a,this._matrices2x2[a]);for(a in this._vectors2Arrays)o.setArray2(a,this._vectors2Arrays[a]);for(a in this._vectors3Arrays)o.setArray3(a,this._vectors3Arrays[a]);for(a in this._vectors4Arrays)o.setArray4(a,this._vectors4Arrays[a]);for(a in this._quaternionsArrays)o.setArray4(a,this._quaternionsArrays[a]);for(a in this._uniformBuffers){const x=this._uniformBuffers[a].getBuffer();x&&o.bindUniformBuffer(x,a)}const p=n.getEngine(),d=p.setExternalTexture;if(d)for(a in this._externalTextures)d.call(p,a,this._externalTextures[a]);const y=p.setTextureSampler;if(y)for(a in this._textureSamplers)y.call(p,a,this._textureSamplers[a]);const _=p.setStorageBuffer;if(_)for(a in this._storageBuffers)_.call(p,a,this._storageBuffers[a])}if(o&&t&&(f||!this.isFrozen)){const a=t.morphTargetManager;a&&a.numInfluencers>0&&Be(t,o);const p=t.bakedVertexAnimationManager;if(p&&p.isEnabled){const d=i?r._drawWrapper:this._drawWrapper;(h=t.bakedVertexAnimationManager)==null||h.bind(o,!!d._wasPreviouslyUsingInstances)}}this._afterBind(t,o,r)}getActiveTextures(){const e=super.getActiveTextures();for(const t in this._textures)e.push(this._textures[t]);for(const t in this._textureArrays){const s=this._textureArrays[t];for(let r=0;r<s.length;r++)e.push(s[r])}return e}hasTexture(e){if(super.hasTexture(e))return!0;for(const t in this._textures)if(this._textures[t]===e)return!0;for(const t in this._textureArrays){const s=this._textureArrays[t];for(let r=0;r<s.length;r++)if(s[r]===e)return!0}return!1}clone(e){const t=C.Clone(()=>new I(e,this.getScene(),this._shaderPath,this._options,this._storeEffectOnSubMeshes),this);t.name=e,t.id=e,typeof t._shaderPath=="object"&&(t._shaderPath={...t._shaderPath}),this._options={...this._options},Object.keys(this._options).forEach(s=>{const r=this._options[s];Array.isArray(r)&&(this._options[s]=r.slice(0))}),this.stencil.copyTo(t.stencil);for(const s in this._textures)t.setTexture(s,this._textures[s]);for(const s in this._textureArrays)t.setTextureArray(s,this._textureArrays[s]);for(const s in this._externalTextures)t.setExternalTexture(s,this._externalTextures[s]);for(const s in this._ints)t.setInt(s,this._ints[s]);for(const s in this._uints)t.setUInt(s,this._uints[s]);for(const s in this._floats)t.setFloat(s,this._floats[s]);for(const s in this._floatsArrays)t.setFloats(s,this._floatsArrays[s]);for(const s in this._colors3)t.setColor3(s,this._colors3[s]);for(const s in this._colors3Arrays)t._colors3Arrays[s]=this._colors3Arrays[s];for(const s in this._colors4)t.setColor4(s,this._colors4[s]);for(const s in this._colors4Arrays)t._colors4Arrays[s]=this._colors4Arrays[s];for(const s in this._vectors2)t.setVector2(s,this._vectors2[s]);for(const s in this._vectors3)t.setVector3(s,this._vectors3[s]);for(const s in this._vectors4)t.setVector4(s,this._vectors4[s]);for(const s in this._quaternions)t.setQuaternion(s,this._quaternions[s]);for(const s in this._quaternionsArrays)t._quaternionsArrays[s]=this._quaternionsArrays[s];for(const s in this._matrices)t.setMatrix(s,this._matrices[s]);for(const s in this._matrixArrays)t._matrixArrays[s]=this._matrixArrays[s].slice();for(const s in this._matrices3x3)t.setMatrix3x3(s,this._matrices3x3[s]);for(const s in this._matrices2x2)t.setMatrix2x2(s,this._matrices2x2[s]);for(const s in this._vectors2Arrays)t.setArray2(s,this._vectors2Arrays[s]);for(const s in this._vectors3Arrays)t.setArray3(s,this._vectors3Arrays[s]);for(const s in this._vectors4Arrays)t.setArray4(s,this._vectors4Arrays[s]);for(const s in this._uniformBuffers)t.setUniformBuffer(s,this._uniformBuffers[s]);for(const s in this._textureSamplers)t.setTextureSampler(s,this._textureSamplers[s]);for(const s in this._storageBuffers)t.setStorageBuffer(s,this._storageBuffers[s]);return t}dispose(e,t,s){if(t){let r;for(r in this._textures)this._textures[r].dispose();for(r in this._textureArrays){const i=this._textureArrays[r];for(let o=0;o<i.length;o++)i[o].dispose()}}this._textures={},super.dispose(e,t,s)}serialize(){const e=C.Serialize(this);e.customType="BABYLON.ShaderMaterial",e.uniqueId=this.uniqueId,e.options=this._options,e.shaderPath=this._shaderPath,e.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes;let t;e.stencil=this.stencil.serialize(),e.textures={};for(t in this._textures)e.textures[t]=this._textures[t].serialize();e.textureArrays={};for(t in this._textureArrays){e.textureArrays[t]=[];const s=this._textureArrays[t];for(let r=0;r<s.length;r++)e.textureArrays[t].push(s[r].serialize())}e.ints={};for(t in this._ints)e.ints[t]=this._ints[t];e.uints={};for(t in this._uints)e.uints[t]=this._uints[t];e.floats={};for(t in this._floats)e.floats[t]=this._floats[t];e.floatsArrays={};for(t in this._floatsArrays)e.floatsArrays[t]=this._floatsArrays[t];e.colors3={};for(t in this._colors3)e.colors3[t]=this._colors3[t].asArray();e.colors3Arrays={};for(t in this._colors3Arrays)e.colors3Arrays[t]=this._colors3Arrays[t];e.colors4={};for(t in this._colors4)e.colors4[t]=this._colors4[t].asArray();e.colors4Arrays={};for(t in this._colors4Arrays)e.colors4Arrays[t]=this._colors4Arrays[t];e.vectors2={};for(t in this._vectors2)e.vectors2[t]=this._vectors2[t].asArray();e.vectors3={};for(t in this._vectors3)e.vectors3[t]=this._vectors3[t].asArray();e.vectors4={};for(t in this._vectors4)e.vectors4[t]=this._vectors4[t].asArray();e.quaternions={};for(t in this._quaternions)e.quaternions[t]=this._quaternions[t].asArray();e.matrices={};for(t in this._matrices)e.matrices[t]=this._matrices[t].asArray();e.matrixArray={};for(t in this._matrixArrays)e.matrixArray[t]=this._matrixArrays[t];e.matrices3x3={};for(t in this._matrices3x3)e.matrices3x3[t]=this._matrices3x3[t];e.matrices2x2={};for(t in this._matrices2x2)e.matrices2x2[t]=this._matrices2x2[t];e.vectors2Arrays={};for(t in this._vectors2Arrays)e.vectors2Arrays[t]=this._vectors2Arrays[t];e.vectors3Arrays={};for(t in this._vectors3Arrays)e.vectors3Arrays[t]=this._vectors3Arrays[t];e.vectors4Arrays={};for(t in this._vectors4Arrays)e.vectors4Arrays[t]=this._vectors4Arrays[t];e.quaternionsArrays={};for(t in this._quaternionsArrays)e.quaternionsArrays[t]=this._quaternionsArrays[t];return e}static Parse(e,t,s){const r=C.Parse(()=>new I(e.name,t,e.shaderPath,e.options,e.storeEffectOnSubMeshes),e,t,s);let i;e.stencil&&r.stencil.parse(e.stencil,t,s);for(i in e.textures)r.setTexture(i,G.Parse(e.textures[i],t,s));for(i in e.textureArrays){const o=e.textureArrays[i],n=[];for(let c=0;c<o.length;c++)n.push(G.Parse(o[c],t,s));r.setTextureArray(i,n)}for(i in e.ints)r.setInt(i,e.ints[i]);for(i in e.uints)r.setUInt(i,e.uints[i]);for(i in e.floats)r.setFloat(i,e.floats[i]);for(i in e.floatsArrays)r.setFloats(i,e.floatsArrays[i]);for(i in e.colors3)r.setColor3(i,V.FromArray(e.colors3[i]));for(i in e.colors3Arrays){const o=e.colors3Arrays[i].reduce((n,c,l)=>(l%3===0?n.push([c]):n[n.length-1].push(c),n),[]).map(n=>V.FromArray(n));r.setColor3Array(i,o)}for(i in e.colors4)r.setColor4(i,F.FromArray(e.colors4[i]));for(i in e.colors4Arrays){const o=e.colors4Arrays[i].reduce((n,c,l)=>(l%4===0?n.push([c]):n[n.length-1].push(c),n),[]).map(n=>F.FromArray(n));r.setColor4Array(i,o)}for(i in e.vectors2)r.setVector2(i,Te.FromArray(e.vectors2[i]));for(i in e.vectors3)r.setVector3(i,T.FromArray(e.vectors3[i]));for(i in e.vectors4)r.setVector4(i,Oe.FromArray(e.vectors4[i]));for(i in e.quaternions)r.setQuaternion(i,we.FromArray(e.quaternions[i]));for(i in e.matrices)r.setMatrix(i,P.FromArray(e.matrices[i]));for(i in e.matrixArray)r._matrixArrays[i]=new Float32Array(e.matrixArray[i]);for(i in e.matrices3x3)r.setMatrix3x3(i,e.matrices3x3[i]);for(i in e.matrices2x2)r.setMatrix2x2(i,e.matrices2x2[i]);for(i in e.vectors2Arrays)r.setArray2(i,e.vectors2Arrays[i]);for(i in e.vectors3Arrays)r.setArray3(i,e.vectors3Arrays[i]);for(i in e.vectors4Arrays)r.setArray4(i,e.vectors4Arrays[i]);for(i in e.quaternionsArrays)r.setArray4(i,e.quaternionsArrays[i]);return r}static ParseFromFileAsync(e,t,s,r=""){return new Promise((i,o)=>{const n=new H;n.addEventListener("readystatechange",()=>{if(n.readyState==4)if(n.status==200){const c=JSON.parse(n.responseText),l=this.Parse(c,s||K.LastCreatedScene,r);e&&(l.name=e),i(l)}else o("Unable to load the ShaderMaterial")}),n.open("GET",t),n.send()})}static ParseFromSnippetAsync(e,t,s=""){return new Promise((r,i)=>{const o=new H;o.addEventListener("readystatechange",()=>{if(o.readyState==4)if(o.status==200){const n=JSON.parse(JSON.parse(o.responseText).jsonPayload),c=JSON.parse(n.shaderMaterial),l=this.Parse(c,t||K.LastCreatedScene,s);l.snippetId=e,r(l)}else i("Unable to load the snippet "+e)}),o.open("GET",this.SnippetUrl+"/"+e.replace(/#/g,"/")),o.send()})}}I.SnippetUrl="https://snippet.babylonjs.com";I.CreateFromSnippetAsync=I.ParseFromSnippetAsync;$("BABYLON.ShaderMaterial",I);S._LinesMeshParser=(u,e)=>b.Parse(u,e);class b extends S{_isShaderMaterial(e){return e.getClassName()==="ShaderMaterial"}constructor(e,t=null,s=null,r=null,i,o,n,c){super(e,t,s,r,i),this.useVertexColor=o,this.useVertexAlpha=n,this.color=new V(1,1,1),this.alpha=1,this._shaderLanguage=0,r&&(this.color=r.color.clone(),this.alpha=r.alpha,this.useVertexColor=r.useVertexColor,this.useVertexAlpha=r.useVertexAlpha),this.intersectionThreshold=.1;const l=[],f={attributes:[A.PositionKind],uniforms:["world","viewProjection"],needAlphaBlending:!0,defines:l,useClipPlane:null,shaderLanguage:0};n?f.defines.push("#define VERTEXALPHA"):f.needAlphaBlending=!1,o?(f.defines.push("#define VERTEXCOLOR"),f.attributes.push(A.ColorKind)):(f.uniforms.push("color"),this._color4=new F),c?this.material=c:(this.getScene().getEngine().isWebGPU&&!b.ForceGLSL&&(this._shaderLanguage=1),f.shaderLanguage=this._shaderLanguage,f.extraInitializationsAsync=async()=>{this._shaderLanguage===1?await Promise.all([D(()=>import("./color.vertex-C6qxQly1.js"),__vite__mapDeps([0,1,2,3,4,5,6,7,8]),import.meta.url),D(()=>import("./color.fragment-BDtywhH2.js"),__vite__mapDeps([9,1,2,3,4,5,6,7,10]),import.meta.url)]):await Promise.all([D(()=>import("./color.vertex-D6vLhBMM.js"),__vite__mapDeps([11,1,2,3,4,5,6,7,12]),import.meta.url),D(()=>import("./color.fragment-BN4sNh-W.js"),__vite__mapDeps([13,1,2,3,4,5,6,7,14]),import.meta.url)])},this.material=new I("colorShader",this.getScene(),"color",f,!1),this.material.doNotSerialize=!0)}isReady(){return this._lineMaterial.isReady(this,!!this._userInstancedBuffersStorage||this.hasThinInstances)?super.isReady():!1}getClassName(){return"LinesMesh"}get material(){return this._lineMaterial}set material(e){this._lineMaterial=e,this._lineMaterial.fillMode=L.LineListDrawMode}get checkCollisions(){return!1}set checkCollisions(e){}_bind(e,t){if(!this._geometry)return this;const s=this.isUnIndexed?null:this._geometry.getIndexBuffer();if(!this._userInstancedBuffersStorage||this.hasThinInstances?this._geometry._bind(t,s):this._geometry._bind(t,s,this._userInstancedBuffersStorage.vertexBuffers,this._userInstancedBuffersStorage.vertexArrayObjects),!this.useVertexColor&&this._isShaderMaterial(this._lineMaterial)){const{r,g:i,b:o}=this.color;this._color4.set(r,i,o,this.alpha),this._lineMaterial.setColor4("color",this._color4)}return this}_draw(e,t,s){if(!this._geometry||!this._geometry.getVertexBuffers()||!this._unIndexed&&!this._geometry.getIndexBuffer())return this;const r=this.getScene().getEngine();return this._unIndexed?r.drawArraysType(L.LineListDrawMode,e.verticesStart,e.verticesCount,s):r.drawElementsType(L.LineListDrawMode,e.indexStart,e.indexCount,s),this}dispose(e,t=!1,s){s||this._lineMaterial.dispose(!1,!1,!0),super.dispose(e)}clone(e,t=null,s){return new b(e,this.getScene(),t,this,s)}createInstance(e){const t=new Ue(e,this);if(this.instancedBuffers){t.instancedBuffers={};for(const s in this.instancedBuffers)t.instancedBuffers[s]=this.instancedBuffers[s]}return t}serialize(e){super.serialize(e),e.color=this.color.asArray(),e.alpha=this.alpha}static Parse(e,t){const s=new b(e.name,t);return s.color=V.FromArray(e.color),s.alpha=e.alpha,s}}b.ForceGLSL=!1;class Ue extends z{constructor(e,t){super(e,t),this.intersectionThreshold=t.intersectionThreshold}getClassName(){return"InstancedLinesMesh"}}function Q(u){const e=[],t=[],s=u.lines,r=u.colors,i=[];let o=0;for(let c=0;c<s.length;c++){const l=s[c];for(let f=0;f<l.length;f++){const{x:h,y:a,z:p}=l[f];if(t.push(h,a,p),r){const d=r[c],{r:y,g:_,b:x,a:M}=d[f];i.push(y,_,x,M)}f>0&&(e.push(o-1),e.push(o)),o++}}const n=new E;return n.indices=e,n.positions=t,r&&(n.colors=i),n}function X(u){const e=u.dashSize||3,t=u.gapSize||1,s=u.dashNb||200,r=u.points,i=[],o=[],n=T.Zero();let c=0,l=0,f=0,h=0,a=0,p=0,d=0;for(d=0;d<r.length-1;d++)r[d+1].subtractToRef(r[d],n),c+=n.length();for(f=c/s,h=e*f/(e+t),d=0;d<r.length-1;d++){r[d+1].subtractToRef(r[d],n),l=Math.floor(n.length()/f),n.normalize();for(let _=0;_<l;_++)a=f*_,i.push(r[d].x+a*n.x,r[d].y+a*n.y,r[d].z+a*n.z),i.push(r[d].x+(a+h)*n.x,r[d].y+(a+h)*n.y,r[d].z+(a+h)*n.z),o.push(p,p+1),p+=2}const y=new E;return y.positions=i,y.indices=o,y}function Ne(u,e,t=null){const s=e.instance,r=e.lines,i=e.colors;if(s){const l=s.getVerticesData(A.PositionKind);let f,h;i&&(f=s.getVerticesData(A.ColorKind));let a=0,p=0;for(let d=0;d<r.length;d++){const y=r[d];for(let _=0;_<y.length;_++)l[a]=y[_].x,l[a+1]=y[_].y,l[a+2]=y[_].z,i&&f&&(h=i[d],f[p]=h[_].r,f[p+1]=h[_].g,f[p+2]=h[_].b,f[p+3]=h[_].a,p+=4),a+=3}return s.updateVerticesData(A.PositionKind,l,!1,!1),i&&f&&s.updateVerticesData(A.ColorKind,f,!1,!1),s.refreshBoundingInfo(),s}const o=!!i,n=new b(u,t,null,void 0,void 0,o,e.useVertexAlpha,e.material);return Q(e).applyToMesh(n,e.updatable),n}function je(u,e,t=null){const s=e.colors?[e.colors]:null;return Ne(u,{lines:[e.points],updatable:e.updatable,instance:e.instance,colors:s,useVertexAlpha:e.useVertexAlpha,material:e.material},t)}function J(u,e,t=null){const s=e.points,r=e.instance,i=e.gapSize||1,o=e.dashSize||3;if(r){const l=f=>{const h=T.Zero(),a=f.length/6;let p=0,d=0,y=0,_=0,x=0,M=0,m=0,v=0;for(m=0;m<s.length-1;m++)s[m+1].subtractToRef(s[m],h),p+=h.length();y=p/a;const g=r._creationDataStorage.dashSize,O=r._creationDataStorage.gapSize;for(_=g*y/(g+O),m=0;m<s.length-1;m++)for(s[m+1].subtractToRef(s[m],h),d=Math.floor(h.length()/y),h.normalize(),v=0;v<d&&M<f.length;)x=y*v,f[M]=s[m].x+x*h.x,f[M+1]=s[m].y+x*h.y,f[M+2]=s[m].z+x*h.z,f[M+3]=s[m].x+(x+_)*h.x,f[M+4]=s[m].y+(x+_)*h.y,f[M+5]=s[m].z+(x+_)*h.z,M+=6,v++;for(;M<f.length;)f[M]=s[m].x,f[M+1]=s[m].y,f[M+2]=s[m].z,M+=3};return(e.dashNb||e.dashSize||e.gapSize||e.useVertexAlpha||e.material)&&R.Warn("You have used an option other than points with the instance option. Please be aware that these other options will be ignored."),r.updateMeshPositions(l,!1),r}const n=new b(u,t,null,void 0,void 0,void 0,e.useVertexAlpha,e.material);return X(e).applyToMesh(n,e.updatable),n._creationDataStorage=new Pe,n._creationDataStorage.dashSize=o,n._creationDataStorage.gapSize=i,n}E.CreateLineSystem=Q;E.CreateDashedLines=X;S.CreateLines=(u,e,t=null,s=!1,r=null)=>je(u,{points:e,updatable:s,instance:r},t);S.CreateDashedLines=(u,e,t,s,r,i=null,o,n)=>J(u,{points:e,dashSize:t,gapSize:s,dashNb:r,updatable:o,instance:n},i);function U(u,e){let t=ee(e,"mesh",15),s=se(e,["$$slots","$$events","$$legacy","mesh"]);Ve(u,te({createMeshFunction:J},()=>s,{get mesh(){return t()},set mesh(r){t(r)}}))}U.__docgen={data:[{name:"mesh",visibility:"public",description:"if you want to use a mesh api, bind it",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"LinesMesh"},static:!1,readonly:!1,defaultValue:"..."},{name:"options",visibility:"public",keywords:[{name:"required",description:""}],kind:"let",type:{kind:"type",type:"object",text:"{ dashNb?: number | undefined; dashSize?: number | undefined; gapSize?: number | undefined; instance?: LinesMesh | undefined; material?: Material | undefined; points: Vector3[]; updatable?: boolean | undefined; useVertexAlpha?: boolean | undefined; }"},static:!1,readonly:!1},{name:"scene",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"Scene"},static:!1,readonly:!1},{name:"children",visibility:"public",keywords:[],kind:"let",type:{kind:"function",text:"Snippet<[]>"},static:!1,readonly:!1},{name:"position",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"{ x: number; y: number; z: number; }"},static:!1,readonly:!1},{name:"rotation",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"{ x: number; y: number; z: number; }"},static:!1,readonly:!1},{name:"scaling",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"{ x: number; y: number; z: number; }"},static:!1,readonly:!1}],name:"DashedLine.svelte"};const We={title:"mesh/DashedLine",tags:["autodocs"],component:U},{Story:qe}=Ce();var Ge=ne("<!> <!> <!>",1);function Y(u,e){ae(e,!1),re(),qe(u,{name:"Docs",args:{options:{dashNb:20,dashSize:4,gapSize:4,instance:void 0,material:void 0,points:[{x:-2,y:4,z:-8},{x:2,y:4,z:-8}],updatable:void 0,useVertexAlpha:void 0},position:{x:0,y:0,z:0},rotation:{x:0,y:0,z:0},scaling:{x:1,y:1,z:1}},children:(s,r=fe)=>{Le(s,{style:"width: 100%;",children:(i,o)=>{ke(i,{children:(n,c)=>{Re(n,{children:(l,f)=>{var h=Ge(),a=he(h);Fe(a,{position:new T(0,5,-10)});var p=W(a,2);ze(p,{direction:new T(0,1,0),intensity:.7});var d=W(p,2),y=ue(()=>{var _;return{...r().options,points:((_=r().options)==null?void 0:_.points.map(x=>new T(x.x,x.y,x.z)))||[]}});U(d,{get options(){return ce(y)},get position(){return r().position},get rotation(){return r().rotation},get scaling(){return r().scaling}}),ie(l,h)},$$slots:{default:!0}})},$$slots:{default:!0}})},$$slots:{default:!0}})},$$slots:{default:!0},parameters:{__svelteCsf:{rawCode:`<Canvas style="width: 100%;">
  <Engine>
    <Scene>
      <FreeCamera position={new Vector3(0, 5, -10)} />
      <HemisphericLight direction={new Vector3(0, 1, 0)} intensity={0.7} />
      <DashedLine
        options={{
          ...args.options,
          points:
            args.options?.points.map((point) => new Vector3(point.x, point.y, point.z)) || []
        }}
        position={args.position}
        rotation={args.rotation}
        scaling={args.scaling}
      />
    </Scene>
  </Engine>
</Canvas>`}}}),oe()}Y.__docgen={version:3,name:"DashedLine.stories.svelte",data:[],computed:[],methods:[],components:[],description:null,keywords:[],events:[],slots:[],refs:[]};const He=Ee(Y,We),tt=["Docs"],st=He.Docs;export{st as Docs,tt as __namedExportsOrder,We as default};
