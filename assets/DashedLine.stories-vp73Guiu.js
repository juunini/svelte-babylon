const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./color.vertex-CRzRKV9z.js","./create-runtime-stories-CMkdhrdB.js","./props-CDwtXEPn.js","./index-client-0IVJ1HVs.js","./iframe-p99vTRwq.js","./index-D-8MO0q_.js","./index-BHYIh-Xd.js","./_commonjsHelpers-Cpj98o6Y.js","./clipPlaneVertex-CXiOpr98.js","./vertexColorMixing-BT_zPiJn.js","./instancesDeclaration-2Ytj9UKe.js","./instancesVertex-C0AMtBdM.js","./color.fragment-P1tr8LpK.js","./clipPlaneFragment-C1-bY7nG.js","./fogFragment-Bnh5sbEz.js","./color.vertex-h0yqQ0CT.js","./vertexColorMixing-3IGVszkz.js","./color.fragment-Cw0tp2FY.js","./fogFragment-BYH2xGZ8.js"])))=>i.map(i=>d[i]);
import{p as B,s as N,r as $,i as O,a as H,t as j}from"./props-CDwtXEPn.js";import{p as F,a as G,f as K,s as E,g as U,n as X,d as Y}from"./index-client-0IVJ1HVs.js";import{M as L,G as T,n as q,J as W,K as P,N as Z,O as _,u as C,V as v,o as J,Q,k as ee,c as te,d as se,C as ne,E as ie,S as ae,H as re}from"./create-runtime-stories-CMkdhrdB.js";import{F as oe}from"./FreeCamera-DQnrkUYb.js";import{_ as w}from"./iframe-p99vTRwq.js";import"./index-D-8MO0q_.js";import"./index-BHYIh-Xd.js";import"./_commonjsHelpers-Cpj98o6Y.js";import"../sb-preview/runtime.js";L._LinesMeshParser=(l,e)=>S.Parse(l,e);class S extends L{_isShaderMaterial(e){return e.getClassName()==="ShaderMaterial"}constructor(e,i=null,t=null,s=null,d,u,a,b){super(e,i,t,s,d),this.useVertexColor=u,this.useVertexAlpha=a,this.color=new T(1,1,1),this.alpha=1,this._shaderLanguage=0,s&&(this.color=s.color.clone(),this.alpha=s.alpha,this.useVertexColor=s.useVertexColor,this.useVertexAlpha=s.useVertexAlpha),this.intersectionThreshold=.1;const m=[],n={attributes:[_.PositionKind],uniforms:["world","viewProjection"],needAlphaBlending:!0,defines:m,useClipPlane:null,shaderLanguage:0};a?n.defines.push("#define VERTEXALPHA"):n.needAlphaBlending=!1,u?(n.defines.push("#define VERTEXCOLOR"),n.attributes.push(_.ColorKind)):(n.uniforms.push("color"),this._color4=new q),b?this.material=b:(this.getScene().getEngine().isWebGPU&&!S.ForceGLSL&&(this._shaderLanguage=1),n.shaderLanguage=this._shaderLanguage,n.extraInitializationsAsync=async()=>{this._shaderLanguage===1?await Promise.all([w(()=>import("./color.vertex-CRzRKV9z.js"),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11]),import.meta.url),w(()=>import("./color.fragment-P1tr8LpK.js"),__vite__mapDeps([12,1,2,3,4,5,6,7,13,14]),import.meta.url)]):await Promise.all([w(()=>import("./color.vertex-h0yqQ0CT.js"),__vite__mapDeps([15,1,2,3,4,5,6,7,16]),import.meta.url),w(()=>import("./color.fragment-Cw0tp2FY.js"),__vite__mapDeps([17,1,2,3,4,5,6,7,18]),import.meta.url)])},this.material=new W("colorShader",this.getScene(),"color",n,!1),this.material.doNotSerialize=!0)}isReady(){return this._lineMaterial.isReady(this,!!this._userInstancedBuffersStorage||this.hasThinInstances)?super.isReady():!1}getClassName(){return"LinesMesh"}get material(){return this._lineMaterial}set material(e){this._lineMaterial=e,this._lineMaterial.fillMode=P.LineListDrawMode}get checkCollisions(){return!1}set checkCollisions(e){}_bind(e,i){if(!this._geometry)return this;const t=this.isUnIndexed?null:this._geometry.getIndexBuffer();if(!this._userInstancedBuffersStorage||this.hasThinInstances?this._geometry._bind(i,t):this._geometry._bind(i,t,this._userInstancedBuffersStorage.vertexBuffers,this._userInstancedBuffersStorage.vertexArrayObjects),!this.useVertexColor&&this._isShaderMaterial(this._lineMaterial)){const{r:s,g:d,b:u}=this.color;this._color4.set(s,d,u,this.alpha),this._lineMaterial.setColor4("color",this._color4)}return this}_draw(e,i,t){if(!this._geometry||!this._geometry.getVertexBuffers()||!this._unIndexed&&!this._geometry.getIndexBuffer())return this;const s=this.getScene().getEngine();return this._unIndexed?s.drawArraysType(P.LineListDrawMode,e.verticesStart,e.verticesCount,t):s.drawElementsType(P.LineListDrawMode,e.indexStart,e.indexCount,t),this}dispose(e,i=!1,t){t||this._lineMaterial.dispose(!1,!1,!0),super.dispose(e)}clone(e,i=null,t){return new S(e,this.getScene(),i,this,t)}createInstance(e){const i=new le(e,this);if(this.instancedBuffers){i.instancedBuffers={};for(const t in this.instancedBuffers)i.instancedBuffers[t]=this.instancedBuffers[t]}return i}serialize(e){super.serialize(e),e.color=this.color.asArray(),e.alpha=this.alpha}static Parse(e,i){const t=new S(e.name,i);return t.color=T.FromArray(e.color),t.alpha=e.alpha,t}}S.ForceGLSL=!1;class le extends Z{constructor(e,i){super(e,i),this.intersectionThreshold=i.intersectionThreshold}getClassName(){return"InstancedLinesMesh"}}function V(l){const e=[],i=[],t=l.lines,s=l.colors,d=[];let u=0;for(let b=0;b<t.length;b++){const m=t[b];for(let n=0;n<m.length;n++){const{x:r,y:h,z:y}=m[n];if(i.push(r,h,y),s){const o=s[b],{r:f,g:c,b:x,a:g}=o[n];d.push(f,c,x,g)}n>0&&(e.push(u-1),e.push(u)),u++}}const a=new C;return a.indices=e,a.positions=i,s&&(a.colors=d),a}function I(l){const e=l.dashSize||3,i=l.gapSize||1,t=l.dashNb||200,s=l.points,d=[],u=[],a=v.Zero();let b=0,m=0,n=0,r=0,h=0,y=0,o=0;for(o=0;o<s.length-1;o++)s[o+1].subtractToRef(s[o],a),b+=a.length();for(n=b/t,r=e*n/(e+i),o=0;o<s.length-1;o++){s[o+1].subtractToRef(s[o],a),m=Math.floor(a.length()/n),a.normalize();for(let c=0;c<m;c++)h=n*c,d.push(s[o].x+h*a.x,s[o].y+h*a.y,s[o].z+h*a.z),d.push(s[o].x+(h+r)*a.x,s[o].y+(h+r)*a.y,s[o].z+(h+r)*a.z),u.push(y,y+1),y+=2}const f=new C;return f.positions=d,f.indices=u,f}function de(l,e,i=null){const t=e.instance,s=e.lines,d=e.colors;if(t){const m=t.getVerticesData(_.PositionKind);let n,r;d&&(n=t.getVerticesData(_.ColorKind));let h=0,y=0;for(let o=0;o<s.length;o++){const f=s[o];for(let c=0;c<f.length;c++)m[h]=f[c].x,m[h+1]=f[c].y,m[h+2]=f[c].z,d&&n&&(r=d[o],n[y]=r[c].r,n[y+1]=r[c].g,n[y+2]=r[c].b,n[y+3]=r[c].a,y+=4),h+=3}return t.updateVerticesData(_.PositionKind,m,!1,!1),d&&n&&t.updateVerticesData(_.ColorKind,n,!1,!1),t.refreshBoundingInfo(),t}const u=!!d,a=new S(l,i,null,void 0,void 0,u,e.useVertexAlpha,e.material);return V(e).applyToMesh(a,e.updatable),a}function ce(l,e,i=null){const t=e.colors?[e.colors]:null;return de(l,{lines:[e.points],updatable:e.updatable,instance:e.instance,colors:t,useVertexAlpha:e.useVertexAlpha,material:e.material},i)}function M(l,e,i=null){const t=e.points,s=e.instance,d=e.gapSize||1,u=e.dashSize||3;if(s){const m=n=>{const r=v.Zero(),h=n.length/6;let y=0,o=0,f=0,c=0,x=0,g=0,p=0,k=0;for(p=0;p<t.length-1;p++)t[p+1].subtractToRef(t[p],r),y+=r.length();f=y/h;const D=s._creationDataStorage.dashSize,R=s._creationDataStorage.gapSize;for(c=D*f/(D+R),p=0;p<t.length-1;p++)for(t[p+1].subtractToRef(t[p],r),o=Math.floor(r.length()/f),r.normalize(),k=0;k<o&&g<n.length;)x=f*k,n[g]=t[p].x+x*r.x,n[g+1]=t[p].y+x*r.y,n[g+2]=t[p].z+x*r.z,n[g+3]=t[p].x+(x+c)*r.x,n[g+4]=t[p].y+(x+c)*r.y,n[g+5]=t[p].z+(x+c)*r.z,g+=6,k++;for(;g<n.length;)n[g]=t[p].x,n[g+1]=t[p].y,n[g+2]=t[p].z,g+=3};return(e.dashNb||e.dashSize||e.gapSize||e.useVertexAlpha||e.material)&&J.Warn("You have used an option other than points with the instance option. Please be aware that these other options will be ignored."),s.updateMeshPositions(m,!1),s}const a=new S(l,i,null,void 0,void 0,void 0,e.useVertexAlpha,e.material);return I(e).applyToMesh(a,e.updatable),a._creationDataStorage=new Q,a._creationDataStorage.dashSize=u,a._creationDataStorage.gapSize=d,a}C.CreateLineSystem=V;C.CreateDashedLines=I;L.CreateLines=(l,e,i=null,t=!1,s=null)=>ce(l,{points:e,updatable:t,instance:s},i);L.CreateDashedLines=(l,e,i,t,s,d=null,u,a)=>M(l,{points:e,dashSize:i,gapSize:t,dashNb:s,updatable:u,instance:a},d);function z(l,e){let i=B(e,"mesh",15),t=$(e,["$$slots","$$events","$$legacy","mesh"]);ee(l,N({createMeshFunction:M},()=>t,{get mesh(){return i()},set mesh(s){i(s)}}))}z.__docgen={data:[{name:"mesh",visibility:"public",description:"if you want to use a mesh api, bind it",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"LinesMesh"},static:!1,readonly:!1,defaultValue:"..."},{name:"options",visibility:"public",keywords:[{name:"required",description:""}],kind:"let",type:{kind:"type",type:"object",text:"{ dashNb?: number | undefined; dashSize?: number | undefined; gapSize?: number | undefined; instance?: LinesMesh | undefined; material?: Material | undefined; points: Vector3[]; updatable?: boolean | undefined; useVertexAlpha?: boolean | undefined; }"},static:!1,readonly:!1},{name:"scene",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"Scene"},static:!1,readonly:!1},{name:"children",visibility:"public",keywords:[],kind:"let",type:{kind:"function",text:"Snippet<[]>"},static:!1,readonly:!1},{name:"physics",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"boolean",text:"boolean"},static:!1,readonly:!1},{name:"physicsShape",visibility:"public",keywords:[],kind:"let",type:{kind:"union",type:[{kind:"const",type:"number",value:0,text:"PhysicsShapeType.SPHERE"},{kind:"const",type:"number",value:1,text:"PhysicsShapeType.CAPSULE"},{kind:"const",type:"number",value:2,text:"PhysicsShapeType.CYLINDER"},{kind:"const",type:"number",value:3,text:"PhysicsShapeType.BOX"},{kind:"const",type:"number",value:4,text:"PhysicsShapeType.CONVEX_HULL"},{kind:"const",type:"number",value:5,text:"PhysicsShapeType.CONTAINER"},{kind:"const",type:"number",value:6,text:"PhysicsShapeType.MESH"},{kind:"const",type:"number",value:7,text:"PhysicsShapeType.HEIGHTFIELD"},{kind:"type",type:"object",text:"PhysicsShape"}],text:"PhysicsShapeType.SPHERE | PhysicsShapeType.CAPSULE | PhysicsShapeType.CYLINDER | PhysicsShapeType.BOX | PhysicsShapeType.CONVEX_HULL | PhysicsShapeType.CONTAINER | PhysicsShapeType.MESH | PhysicsShapeType.HEIGHTFIELD | PhysicsShape"},static:!1,readonly:!1},{name:"physicsOptions",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"PhysicsAggregateParameters"},static:!1,readonly:!1},{name:"position",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"{ x: number; y: number; z: number; }"},static:!1,readonly:!1},{name:"rotation",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"{ x: number; y: number; z: number; }"},static:!1,readonly:!1},{name:"scaling",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"{ x: number; y: number; z: number; }"},static:!1,readonly:!1},{name:"force",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"{ x: number; y: number; z: number; }"},static:!1,readonly:!1},{name:"impulse",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"{ x: number; y: number; z: number; }"},static:!1,readonly:!1},{name:"receivedShadows",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"boolean",text:"boolean"},static:!1,readonly:!1},{name:"shadowEnabled",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"boolean",text:"boolean"},static:!1,readonly:!1},{name:"shadowGroup",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"array",text:"string[]"},static:!1,readonly:!1},{name:"onCollision",visibility:"public",keywords:[],kind:"let",type:{kind:"function",text:"(eventData: IPhysicsCollisionEvent, eventState: EventState) => void"},static:!1,readonly:!1},{name:"onCollisionOnce",visibility:"public",keywords:[],kind:"let",type:{kind:"function",text:"(eventData: IPhysicsCollisionEvent, eventState: EventState) => void"},static:!1,readonly:!1}],name:"DashedLine.svelte"};const he={title:"mesh/DashedLine",tags:["autodocs"],component:z},{Story:pe}=se();var ue=j("<!> <!> <!>",1);function A(l,e){F(e,!1),O(),pe(l,{name:"Docs",args:{options:{dashNb:20,dashSize:4,gapSize:4,instance:void 0,material:void 0,points:[{x:-2,y:4,z:-8},{x:2,y:4,z:-8}],updatable:void 0,useVertexAlpha:void 0},position:{x:0,y:0,z:0},rotation:{x:0,y:0,z:0},scaling:{x:1,y:1,z:1}},children:(t,s=X)=>{ne(t,{style:"width: 100%;",children:(d,u)=>{ie(d,{children:(a,b)=>{ae(a,{children:(m,n)=>{var r=ue(),h=K(r);oe(h,{position:new v(0,5,-10)});var y=E(h,2);re(y,{direction:new v(0,1,0),intensity:.7});var o=E(y,2),f=Y(()=>{var c;return{...s().options,points:((c=s().options)==null?void 0:c.points.map(x=>new v(x.x,x.y,x.z)))||[]}});z(o,{get options(){return U(f)},get position(){return s().position},get rotation(){return s().rotation},get scaling(){return s().scaling}}),H(m,r)},$$slots:{default:!0}})},$$slots:{default:!0}})},$$slots:{default:!0}})},$$slots:{default:!0},parameters:{__svelteCsf:{rawCode:`<Canvas style="width: 100%;">
  <Engine>
    <Scene>
      <FreeCamera position={new Vector3(0, 5, -10)} />
      <HemisphericLight direction={new Vector3(0, 1, 0)} intensity={0.7} />
      <DashedLine
        options={{
          ...args.options,
          points:
            args.options?.points.map((point) => new Vector3(point.x, point.y, point.z)) || []
        }}
        position={args.position}
        rotation={args.rotation}
        scaling={args.scaling}
      />
    </Scene>
  </Engine>
</Canvas>`}}}),G()}A.__docgen={version:3,name:"DashedLine.stories.svelte",data:[],computed:[],methods:[],components:[],description:null,keywords:[],events:[],slots:[],refs:[]};const ye=te(A,he),we=["Docs"],Le=ye.Docs;export{Le as Docs,we as __namedExportsOrder,he as default};
