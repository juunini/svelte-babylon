import{s as D,R as yt,t as Ct,I as Ft,_ as dt,i as T,C as U}from"./create-runtime-stories-BBH7VRGR.js";import{C as _t}from"./passPostProcess-BSd7tJEF.js";import"./props-D_CwaEcb.js";import"./index-client-a4XWVA08.js";import"./iframe-CWYB0b8a.js";import"../sb-preview/runtime.js";import"./index-D-8MO0q_.js";import"./index-BHYIh-Xd.js";import"./_commonjsHelpers-Cpj98o6Y.js";let N,Y;function H(p){N||(N=new Float32Array(1),Y=new Int32Array(N.buffer)),N[0]=p;const a=Y[0];let t=a>>16&32768,e=a>>12&2047;const s=a>>23&255;return s<103?t:s>142?(t|=31744,t|=(s==255?0:1)&&a&8388607,t):s<113?(e|=2048,t|=(e>>114-s)+(e>>113-s&1),t):(t|=s-112<<10|e>>1,t+=e&1,t)}function I(p){const a=(p&32768)>>15,t=(p&31744)>>10,e=p&1023;return t===0?(a?-1:1)*Math.pow(2,-14)*(e/Math.pow(2,10)):t==31?e?NaN:(a?-1:1)*(1/0):(a?-1:1)*Math.pow(2,t-15)*(1+e/Math.pow(2,10))}D.prototype._partialLoadFile=function(p,a,t,e,s=null){const i=r=>{t[a]=r,t._internalCount++,t._internalCount===6&&e(t)},u=(r,c)=>{s&&r&&s(r.status+" "+r.statusText,c)};this._loadFile(p,i,void 0,void 0,!0,u)};D.prototype._cascadeLoadFiles=function(p,a,t,e=null){const s=[];s._internalCount=0;for(let i=0;i<6;i++)this._partialLoadFile(t[i],i,s,a,e)};D.prototype._cascadeLoadImgs=function(p,a,t,e,s=null,i){const u=[];u._internalCount=0;for(let r=0;r<6;r++)this._partialLoadImg(e[r],r,u,p,a,t,s,i)};D.prototype._partialLoadImg=function(p,a,t,e,s,i,u=null,r){const c=yt();Ct(p,l=>{t[a]=l,t._internalCount++,e&&e.removePendingData(c),t._internalCount===6&&i&&i(s,t)},(l,f)=>{e&&e.removePendingData(c),u&&u(l,f)},e?e.offlineProvider:null,r),e&&e.addPendingData(c)};D.prototype.createCubeTextureBase=function(p,a,t,e,s=null,i=null,u,r=null,c=!1,n=0,o=0,l=null,f=null,m=null,y=!1,C=null){const A=l||new Ft(this,7);A.isCube=!0,A.url=p,A.generateMipMaps=!e,A._lodGenerationScale=n,A._lodGenerationOffset=o,A._useSRGBBuffer=!!y&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!e),A!==l&&(A.label=p.substring(0,60)),this._doNotHandleContextLost||(A._extension=r,A._files=t,A._buffer=C);const _=p;this._transformTextureUrl&&!l&&(p=this._transformTextureUrl(p));const b=p.split("?")[0],P=b.lastIndexOf("."),g=r||(P>-1?b.substring(P).toLowerCase():""),O=dt(g),M=(d,G)=>{p===_?i&&d&&i(d.status+" "+d.statusText,G):(T.Warn(`Failed to load ${p}, falling back to the ${_}`),this.createCubeTextureBase(_,a,t,!!e,s,i,u,r,c,n,o,A,f,m,y,C))};if(O)O.then(d=>{const G=R=>{f&&f(A,R),d.loadCubeData(R,A,c,s,i)};C?G(C):t&&t.length===6?d.supportCascades?this._cascadeLoadFiles(a,R=>G(R.map(X=>new Uint8Array(X))),t,i):i?i("Textures type does not support cascades."):T.Warn("Texture loader does not support cascades."):this._loadFile(p,R=>G(new Uint8Array(R)),void 0,void 0,!0,M)});else{if(!t||t.length===0)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(a,A,(d,G)=>{m&&m(d,G)},t,i)}return this._internalTexturesCache.push(A),A};const mt=542327876,Z=131072,v=512,S=4,q=64,tt=131072;function z(p){return p.charCodeAt(0)+(p.charCodeAt(1)<<8)+(p.charCodeAt(2)<<16)+(p.charCodeAt(3)<<24)}function ht(p){return String.fromCharCode(p&255,p>>8&255,p>>16&255,p>>24&255)}const et=z("DXT1"),rt=z("DXT3"),at=z("DXT5"),$=z("DX10"),nt=113,st=116,ot=2,ft=10,Gt=88,j=31,xt=0,bt=1,it=2,ct=3,J=4,lt=7,K=20,ut=21,Bt=22,Rt=23,Ot=24,wt=25,Ut=26,It=28,gt=32;class F{static GetDDSInfo(a){const t=new Int32Array(a.buffer,a.byteOffset,j),e=new Int32Array(a.buffer,a.byteOffset,j+4);let s=1;t[it]&Z&&(s=Math.max(1,t[lt]));const i=t[ut],u=i===$?e[gt]:0;let r=0;switch(i){case nt:r=2;break;case st:r=1;break;case $:if(u===ft){r=2;break}if(u===ot){r=1;break}}return{width:t[J],height:t[ct],mipmapCount:s,isFourCC:(t[K]&S)===S,isRGB:(t[K]&q)===q,isLuminance:(t[K]&tt)===tt,isCube:(t[It]&v)===v,isCompressed:i===et||i===rt||i===at,dxgiFormat:u,textureType:r}}static _GetHalfFloatAsFloatRGBAArrayBuffer(a,t,e,s,i,u){const r=new Float32Array(s),c=new Uint16Array(i,e);let n=0;for(let o=0;o<t;o++)for(let l=0;l<a;l++){const f=(l+o*a)*4;r[n]=I(c[f]),r[n+1]=I(c[f+1]),r[n+2]=I(c[f+2]),F.StoreLODInAlphaChannel?r[n+3]=u:r[n+3]=I(c[f+3]),n+=4}return r}static _GetHalfFloatRGBAArrayBuffer(a,t,e,s,i,u){if(F.StoreLODInAlphaChannel){const r=new Uint16Array(s),c=new Uint16Array(i,e);let n=0;for(let o=0;o<t;o++)for(let l=0;l<a;l++){const f=(l+o*a)*4;r[n]=c[f],r[n+1]=c[f+1],r[n+2]=c[f+2],r[n+3]=H(u),n+=4}return r}return new Uint16Array(i,e,s)}static _GetFloatRGBAArrayBuffer(a,t,e,s,i,u){if(F.StoreLODInAlphaChannel){const r=new Float32Array(s),c=new Float32Array(i,e);let n=0;for(let o=0;o<t;o++)for(let l=0;l<a;l++){const f=(l+o*a)*4;r[n]=c[f],r[n+1]=c[f+1],r[n+2]=c[f+2],r[n+3]=u,n+=4}return r}return new Float32Array(i,e,s)}static _GetFloatAsHalfFloatRGBAArrayBuffer(a,t,e,s,i,u){const r=new Uint16Array(s),c=new Float32Array(i,e);let n=0;for(let o=0;o<t;o++)for(let l=0;l<a;l++)r[n]=H(c[n]),r[n+1]=H(c[n+1]),r[n+2]=H(c[n+2]),F.StoreLODInAlphaChannel?r[n+3]=H(u):r[n+3]=H(c[n+3]),n+=4;return r}static _GetFloatAsUIntRGBAArrayBuffer(a,t,e,s,i,u){const r=new Uint8Array(s),c=new Float32Array(i,e);let n=0;for(let o=0;o<t;o++)for(let l=0;l<a;l++){const f=(l+o*a)*4;r[n]=U(c[f])*255,r[n+1]=U(c[f+1])*255,r[n+2]=U(c[f+2])*255,F.StoreLODInAlphaChannel?r[n+3]=u:r[n+3]=U(c[f+3])*255,n+=4}return r}static _GetHalfFloatAsUIntRGBAArrayBuffer(a,t,e,s,i,u){const r=new Uint8Array(s),c=new Uint16Array(i,e);let n=0;for(let o=0;o<t;o++)for(let l=0;l<a;l++){const f=(l+o*a)*4;r[n]=U(I(c[f]))*255,r[n+1]=U(I(c[f+1]))*255,r[n+2]=U(I(c[f+2]))*255,F.StoreLODInAlphaChannel?r[n+3]=u:r[n+3]=U(I(c[f+3]))*255,n+=4}return r}static _GetRGBAArrayBuffer(a,t,e,s,i,u,r,c,n){const o=new Uint8Array(s),l=new Uint8Array(i,e);let f=0;for(let m=0;m<t;m++)for(let y=0;y<a;y++){const C=(y+m*a)*4;o[f]=l[C+u],o[f+1]=l[C+r],o[f+2]=l[C+c],o[f+3]=l[C+n],f+=4}return o}static _ExtractLongWordOrder(a){return a===0||a===255||a===-16777216?0:1+F._ExtractLongWordOrder(a>>8)}static _GetRGBArrayBuffer(a,t,e,s,i,u,r,c){const n=new Uint8Array(s),o=new Uint8Array(i,e);let l=0;for(let f=0;f<t;f++)for(let m=0;m<a;m++){const y=(m+f*a)*3;n[l]=o[y+u],n[l+1]=o[y+r],n[l+2]=o[y+c],l+=3}return n}static _GetLuminanceArrayBuffer(a,t,e,s,i){const u=new Uint8Array(s),r=new Uint8Array(i,e);let c=0;for(let n=0;n<t;n++)for(let o=0;o<a;o++){const l=o+n*a;u[c]=r[l],c++}return u}static UploadDDSLevels(a,t,e,s,i,u,r=-1,c,n=!0){let o=null;s.sphericalPolynomial&&(o=[]);const l=!!a.getCaps().s3tc;t.generateMipMaps=i;const f=new Int32Array(e.buffer,e.byteOffset,j);let m,y,C,A=0,_,b,P,g,O=0,M=1;if(f[xt]!==mt){T.Error("Invalid magic number in DDS header");return}if(!s.isFourCC&&!s.isRGB&&!s.isLuminance){T.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");return}if(s.isCompressed&&!l){T.Error("Compressed textures are not supported on this platform.");return}let d=f[Bt];_=f[bt]+4;let G=!1;if(s.isFourCC)switch(m=f[ut],m){case et:M=8,O=33777;break;case rt:M=16,O=33778;break;case at:M=16,O=33779;break;case nt:G=!0,d=64;break;case st:G=!0,d=128;break;case $:{_+=5*4;let x=!1;switch(s.dxgiFormat){case ft:G=!0,d=64,x=!0;break;case ot:G=!0,d=128,x=!0;break;case Gt:s.isRGB=!0,s.isFourCC=!1,d=32,x=!0;break}if(x)break}default:T.Error(["Unsupported FourCC code:",ht(m)]);return}const R=F._ExtractLongWordOrder(f[Rt]),X=F._ExtractLongWordOrder(f[Ot]),Q=F._ExtractLongWordOrder(f[wt]),At=F._ExtractLongWordOrder(f[Ut]);G&&(O=a._getRGBABufferInternalSizedFormat(s.textureType)),P=1,f[it]&Z&&i!==!1&&(P=Math.max(1,f[lt]));const pt=c||0,k=a.getCaps();for(let x=pt;x<u;x++){for(y=f[J],C=f[ct],g=0;g<P;++g){if(r===-1||r===g){const h=r===-1?g:0;if(!s.isCompressed&&s.isFourCC){t.format=5,A=y*C*4;let B=null;if(a._badOS||a._badDesktopOS||!k.textureHalfFloat&&!k.textureFloat)d===128?(B=F._GetFloatAsUIntRGBAArrayBuffer(y,C,e.byteOffset+_,A,e.buffer,h),o&&h==0&&o.push(F._GetFloatRGBAArrayBuffer(y,C,e.byteOffset+_,A,e.buffer,h))):d===64&&(B=F._GetHalfFloatAsUIntRGBAArrayBuffer(y,C,e.byteOffset+_,A,e.buffer,h),o&&h==0&&o.push(F._GetHalfFloatAsFloatRGBAArrayBuffer(y,C,e.byteOffset+_,A,e.buffer,h))),t.type=0;else{const W=k.textureFloat&&(n&&k.textureFloatLinearFiltering||!n),E=k.textureHalfFloat&&(n&&k.textureHalfFloatLinearFiltering||!n),V=(d===128||d===64&&!E)&&W?1:(d===64||d===128&&!W)&&E?2:0;let L,w=null;switch(d){case 128:{switch(V){case 1:L=F._GetFloatRGBAArrayBuffer,w=null;break;case 2:L=F._GetFloatAsHalfFloatRGBAArrayBuffer,w=F._GetFloatRGBAArrayBuffer;break;case 0:L=F._GetFloatAsUIntRGBAArrayBuffer,w=F._GetFloatRGBAArrayBuffer;break}break}default:{switch(V){case 1:L=F._GetHalfFloatAsFloatRGBAArrayBuffer,w=null;break;case 2:L=F._GetHalfFloatRGBAArrayBuffer,w=F._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:L=F._GetHalfFloatAsUIntRGBAArrayBuffer,w=F._GetHalfFloatAsFloatRGBAArrayBuffer;break}break}}t.type=V,B=L(y,C,e.byteOffset+_,A,e.buffer,h),o&&h==0&&o.push(w?w(y,C,e.byteOffset+_,A,e.buffer,h):B)}B&&a._uploadDataToTextureDirectly(t,B,x,h)}else if(s.isRGB)t.type=0,d===24?(t.format=4,A=y*C*3,b=F._GetRGBArrayBuffer(y,C,e.byteOffset+_,A,e.buffer,R,X,Q),a._uploadDataToTextureDirectly(t,b,x,h)):(t.format=5,A=y*C*4,b=F._GetRGBAArrayBuffer(y,C,e.byteOffset+_,A,e.buffer,R,X,Q,At),a._uploadDataToTextureDirectly(t,b,x,h));else if(s.isLuminance){const B=a._getUnpackAlignement(),W=y;A=Math.floor((y+B-1)/B)*B*(C-1)+W,b=F._GetLuminanceArrayBuffer(y,C,e.byteOffset+_,A,e.buffer),t.format=1,t.type=0,a._uploadDataToTextureDirectly(t,b,x,h)}else A=Math.max(4,y)/4*Math.max(4,C)/4*M,b=new Uint8Array(e.buffer,e.byteOffset+_,A),t.type=0,a._uploadCompressedDataToTextureDirectly(t,O,y,C,b,x,h)}_+=d?y*C*(d/8):A,y*=.5,C*=.5,y=Math.max(1,y),C=Math.max(1,C)}if(c!==void 0)break}o&&o.length>0?s.sphericalPolynomial=_t.ConvertCubeMapToSphericalPolynomial({size:f[J],right:o[0],left:o[1],up:o[2],down:o[3],front:o[4],back:o[5],format:5,type:1,gammaSpace:!1}):s.sphericalPolynomial=void 0}}F.StoreLODInAlphaChannel=!1;export{F as DDSTools};
