import{p as ce,s as ke,r as ge,i as we,a as Ve,t as Ce}from"./props-CDwtXEPn.js";import{p as ye,a as de,f as ve,g as Se,n as Ue,s as le,d as ze}from"./index-client-0IVJ1HVs.js";import{t as X,M as A,x as Pe,m as ue,l as G,V as E,y as _e,v as pe,u as Ee,j as Te,c as Le,d as De,C as Ae,E as Ne,S as Oe,F as Ie,H as Me}from"./create-runtime-stories-BDqFloR4.js";import"./iframe-wI9NzMPm.js";import"../sb-preview/runtime.js";import"./index-D-8MO0q_.js";import"./index-BHYIh-Xd.js";import"./_commonjsHelpers-Cpj98o6Y.js";function fe(n){const a=n.height||2;let f=n.diameterTop===0?0:n.diameterTop||n.diameter||1,l=n.diameterBottom===0?0:n.diameterBottom||n.diameter||1;f=f||1e-5,l=l||1e-5;const t=(n.tessellation||24)|0,h=(n.subdivisions||1)|0,d=!!n.hasRings,C=!!n.enclose,N=n.cap===0?0:n.cap||A.CAP_ALL,T=n.arc&&(n.arc<=0||n.arc>1)?1:n.arc||1,W=n.sideOrientation===0?0:n.sideOrientation||X.DEFAULTSIDE,i=n.faceUV||new Array(3),s=n.faceColors,B=T!==1&&C?2:0,J=d?h:1,I=2+(1+B)*J;let m;for(m=0;m<I;m++)s&&s[m]===void 0&&(s[m]=new ue(1,1,1,1));for(m=0;m<I;m++)i&&i[m]===void 0&&(i[m]=new G(0,0,1,1));const r=[],b=[],p=[],k=[],v=[],Y=Math.PI*2*T/t;let M,L,R;const Z=(l-f)/2/a,c=E.Zero(),o=E.Zero(),O=E.Zero(),g=E.Zero(),y=E.Zero(),ee=_e.Y;let u,x,j,te=1,e=1,F=0,S=0;for(u=0;u<=h;u++)for(L=u/h,R=(L*(f-l)+l)/2,te=d&&u!==0&&u!==h?2:1,j=0;j<te;j++){for(d&&(e+=j),C&&(e+=2*j),x=0;x<=t;x++)M=x*Y,c.x=Math.cos(-M)*R,c.y=-a/2+L*a,c.z=Math.sin(-M)*R,f===0&&u===h?(o.x=p[p.length-(t+1)*3],o.y=p[p.length-(t+1)*3+1],o.z=p[p.length-(t+1)*3+2]):(o.x=c.x,o.z=c.z,o.y=Math.sqrt(o.x*o.x+o.z*o.z)*Z,o.normalize()),x===0&&(O.copyFrom(c),g.copyFrom(o)),b.push(c.x,c.y,c.z),p.push(o.x,o.y,o.z),d?S=F!==e?i[e].y:i[e].w:S=i[e].y+(i[e].w-i[e].y)*L,k.push(i[e].x+(i[e].z-i[e].x)*x/t,S),s&&v.push(s[e].r,s[e].g,s[e].b,s[e].a);T!==1&&C&&(b.push(c.x,c.y,c.z),b.push(0,c.y,0),b.push(0,c.y,0),b.push(O.x,O.y,O.z),E.CrossToRef(ee,o,y),y.normalize(),p.push(y.x,y.y,y.z,y.x,y.y,y.z),E.CrossToRef(g,ee,y),y.normalize(),p.push(y.x,y.y,y.z,y.x,y.y,y.z),d?S=F!==e?i[e+1].y:i[e+1].w:S=i[e+1].y+(i[e+1].w-i[e+1].y)*L,k.push(i[e+1].x,S),k.push(i[e+1].z,S),d?S=F!==e?i[e+2].y:i[e+2].w:S=i[e+2].y+(i[e+2].w-i[e+2].y)*L,k.push(i[e+2].x,S),k.push(i[e+2].z,S),s&&(v.push(s[e+1].r,s[e+1].g,s[e+1].b,s[e+1].a),v.push(s[e+1].r,s[e+1].g,s[e+1].b,s[e+1].a),v.push(s[e+2].r,s[e+2].g,s[e+2].b,s[e+2].a),v.push(s[e+2].r,s[e+2].g,s[e+2].b,s[e+2].a))),F!==e&&(F=e)}const q=T!==1&&C?t+4:t;for(u=0,e=0;e<h;e++){let w=0,U=0,z=0,D=0;for(x=0;x<t;x++)w=u*(q+1)+x,U=(u+1)*(q+1)+x,z=u*(q+1)+(x+1),D=(u+1)*(q+1)+(x+1),r.push(w,U,z),r.push(D,z,U);T!==1&&C&&(r.push(w+2,U+2,z+2),r.push(D+2,z+2,U+2),r.push(w+4,U+4,z+4),r.push(D+4,z+4,U+4)),u=d?u+2:u+1}const se=w=>{const U=w?f/2:l/2;if(U===0)return;let z,D,P;const V=w?i[I-1]:i[0];let _=null;s&&(_=w?s[I-1]:s[0]);const H=b.length/3,ne=w?a/2:-a/2,K=new E(0,ne,0);b.push(K.x,K.y,K.z),p.push(0,w?1:-1,0);const be=V.y+(V.w-V.y)*.5;k.push(V.x+(V.z-V.x)*.5,be),_&&v.push(_.r,_.g,_.b,_.a);const ie=new pe(.5,.5);for(P=0;P<=t;P++){z=Math.PI*2*P*T/t;const ae=Math.cos(-z),oe=Math.sin(-z);D=new E(ae*U,ne,oe*U);const re=new pe(ae*ie.x+.5,oe*ie.y+.5);b.push(D.x,D.y,D.z),p.push(0,w?1:-1,0);const xe=V.y+(V.w-V.y)*re.y;k.push(V.x+(V.z-V.x)*re.x,xe),_&&v.push(_.r,_.g,_.b,_.a)}for(P=0;P<t;P++)w?(r.push(H),r.push(H+(P+2)),r.push(H+(P+1))):(r.push(H),r.push(H+(P+1)),r.push(H+(P+2)))};(N===A.CAP_START||N===A.CAP_ALL)&&se(!1),(N===A.CAP_END||N===A.CAP_ALL)&&se(!0),X._ComputeSides(W,b,r,p,k,n.frontUVs,n.backUVs);const $=new X;return $.indices=r,$.positions=b,$.normals=p,$.uvs=k,s&&($.colors=v),$}function he(n,a={},f){const l=new A(n,f);return a.sideOrientation=A._GetDefaultSideOrientation(a.sideOrientation),l._originalBuilderSideOrientation=a.sideOrientation,fe(a).applyToMesh(l,a.updatable),l}X.CreateCylinder=fe;A.CreateCylinder=(n,a,f,l,t,h,d,C,N)=>((d===void 0||!(d instanceof Pe))&&(d!==void 0&&(N=C||A.DEFAULTSIDE,C=d),d=h,h=1),he(n,{height:a,diameterTop:f,diameterBottom:l,tessellation:t,subdivisions:h,sideOrientation:N,updatable:C},d));function Q(n,a){ye(a,!0);let f=ce(a,"mesh",15),l=ce(a,"physicsShape",19,()=>Ee.CYLINDER),t=ge(a,["$$slots","$$events","$$legacy","mesh","physicsShape"]);Te(n,ke({createMeshFunction:he,get physicsShape(){return l()}},()=>t,{get mesh(){return f()},set mesh(h){f(h)}})),de()}Q.__docgen={data:[{name:"options",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"{ arc?: number | undefined; backUVs?: Vector4 | undefined; cap?: number | undefined; diameter?: number | undefined; diameterBottom?: number | undefined; diameterTop?: number | undefined; ... 9 more ...; updatable?: boolean | undefined; }"},static:!1,readonly:!1},{name:"scene",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"Scene"},static:!1,readonly:!1},{name:"children",visibility:"public",keywords:[],kind:"let",type:{kind:"function",text:"Snippet<[]>"},static:!1,readonly:!1},{name:"mesh",visibility:"public",description:"if you want to use a mesh api, bind it",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"Mesh"},static:!1,readonly:!1,defaultValue:"..."},{name:"physics",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"boolean",text:"boolean"},static:!1,readonly:!1},{name:"physicsShape",visibility:"public",keywords:[],kind:"let",type:{kind:"union",type:[{kind:"const",type:"number",value:0,text:"PhysicsShapeType.SPHERE"},{kind:"const",type:"number",value:1,text:"PhysicsShapeType.CAPSULE"},{kind:"const",type:"number",value:2,text:"PhysicsShapeType.CYLINDER"},{kind:"const",type:"number",value:3,text:"PhysicsShapeType.BOX"},{kind:"const",type:"number",value:4,text:"PhysicsShapeType.CONVEX_HULL"},{kind:"const",type:"number",value:5,text:"PhysicsShapeType.CONTAINER"},{kind:"const",type:"number",value:6,text:"PhysicsShapeType.MESH"},{kind:"const",type:"number",value:7,text:"PhysicsShapeType.HEIGHTFIELD"},{kind:"type",type:"object",text:"PhysicsShape"}],text:"PhysicsShapeType.SPHERE | PhysicsShapeType.CAPSULE | PhysicsShapeType.CYLINDER | PhysicsShapeType.BOX | PhysicsShapeType.CONVEX_HULL | PhysicsShapeType.CONTAINER | PhysicsShapeType.MESH | PhysicsShapeType.HEIGHTFIELD | PhysicsShape"},static:!1,readonly:!1,defaultValue:"PhysicsShapeType.CYLINDER"},{name:"physicsOptions",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"PhysicsAggregateParameters"},static:!1,readonly:!1},{name:"position",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"{ x: number; y: number; z: number; }"},static:!1,readonly:!1},{name:"rotation",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"{ x: number; y: number; z: number; }"},static:!1,readonly:!1},{name:"scaling",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"{ x: number; y: number; z: number; }"},static:!1,readonly:!1},{name:"force",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"{ x: number; y: number; z: number; }"},static:!1,readonly:!1},{name:"impulse",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"{ x: number; y: number; z: number; }"},static:!1,readonly:!1}],name:"Cylinder.svelte"};const Re={title:"mesh/Cylinder",tags:["autodocs"],component:Q},{Story:$e}=De();var He=Ce("<!> <!> <!>",1);function me(n,a){ye(a,!1),we(),$e(n,{name:"Docs",args:{options:{arc:void 0,backUVs:{x:0,y:0,z:1,w:1},cap:void 0,diameter:4,diameterBottom:void 0,diameterTop:void 0,enclose:void 0,faceColors:[{r:1,g:1,b:1,a:1}],faceUV:[{x:0,y:0,z:1,w:1}],frontUVs:{x:0,y:0,z:1,w:1},hasRings:void 0,height:4,sideOrientation:void 0,subdivisions:void 0,tessellation:void 0,updatable:void 0},position:{x:0,y:0,z:0},rotation:{x:0,y:0,z:0},scaling:{x:1,y:1,z:1}},children:(l,t=Ue)=>{Ae(l,{style:"width: 100%;",children:(h,d)=>{Ne(h,{children:(C,N)=>{Oe(C,{children:(T,W)=>{var i=He(),s=ve(i);Ie(s,{position:new E(0,5,-10)});var B=le(s,2);Me(B,{direction:new E(0,1,0),intensity:.7});var J=le(B,2),I=ze(()=>{var m,r,b,p,k,v,Y,M,L,R,Z,c,o,O;return{...t().options,faceUV:(r=(m=t().options)==null?void 0:m.faceUV)==null?void 0:r.map(g=>new G(g.x,g.y,g.z,g.w)),faceColors:(p=(b=t().options)==null?void 0:b.faceColors)==null?void 0:p.map(g=>new ue(g.r,g.g,g.b,g.a)),frontUVs:(k=t().options)!=null&&k.frontUVs?new G((v=t().options)==null?void 0:v.frontUVs.x,(Y=t().options)==null?void 0:Y.frontUVs.y,(M=t().options)==null?void 0:M.frontUVs.z,(L=t().options)==null?void 0:L.frontUVs.w):void 0,backUVs:(R=t().options)!=null&&R.backUVs?new G((Z=t().options)==null?void 0:Z.backUVs.x,(c=t().options)==null?void 0:c.backUVs.y,(o=t().options)==null?void 0:o.backUVs.z,(O=t().options)==null?void 0:O.backUVs.w):void 0}});Q(J,{get options(){return Se(I)},get position(){return t().position},get rotation(){return t().rotation},get scaling(){return t().scaling}}),Ve(T,i)},$$slots:{default:!0}})},$$slots:{default:!0}})},$$slots:{default:!0}})},$$slots:{default:!0},parameters:{__svelteCsf:{rawCode:`<Canvas style="width: 100%;">
  <Engine>
    <Scene>
      <FreeCamera position={new Vector3(0, 5, -10)} />
      <HemisphericLight direction={new Vector3(0, 1, 0)} intensity={0.7} />
      <Cylinder
        options={{
          ...args.options,
          faceUV: args.options?.faceUV?.map((v) => new Vector4(v.x, v.y, v.z, v.w)),
          faceColors: args.options?.faceColors?.map((v) => new Color4(v.r, v.g, v.b, v.a)),
          frontUVs: args.options?.frontUVs
            ? new Vector4(
                args.options?.frontUVs.x,
                args.options?.frontUVs.y,
                args.options?.frontUVs.z,
                args.options?.frontUVs.w
              )
            : undefined,
          backUVs: args.options?.backUVs
            ? new Vector4(
                args.options?.backUVs.x,
                args.options?.backUVs.y,
                args.options?.backUVs.z,
                args.options?.backUVs.w
              )
            : undefined
        }}
        position={args.position}
        rotation={args.rotation}
        scaling={args.scaling}
      />
    </Scene>
  </Engine>
</Canvas>`}}}),de()}me.__docgen={version:3,name:"Cylinder.stories.svelte",data:[],computed:[],methods:[],components:[],description:null,keywords:[],events:[],slots:[],refs:[]};const je=Le(me,Re),Ke=["Docs"],Qe=je.Docs;export{Qe as Docs,Ke as __namedExportsOrder,Re as default};
