const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./color.vertex-DyanIhrR.js","./create-runtime-stories-DlYX6Gso.js","./props-CDwtXEPn.js","./index-client-0IVJ1HVs.js","./iframe-DXvAOt9X.js","./index-D-8MO0q_.js","./index-BHYIh-Xd.js","./_commonjsHelpers-Cpj98o6Y.js","./clipPlaneVertex-BtnfuJa-.js","./vertexColorMixing-ZXsWCJMg.js","./instancesDeclaration-CnSs-_1h.js","./instancesVertex-pyP4LMuP.js","./color.fragment-Dmriqbf4.js","./clipPlaneFragment-XRu_VNQN.js","./fogFragment-BJ41v2xR.js","./color.vertex-9_e37f4e.js","./vertexColorMixing-BpUagduH.js","./color.fragment-CCDeVv6l.js","./fogFragment-Dl0_Btz7.js"])))=>i.map(i=>d[i]);
import{p as B,s as N,r as $,i as H,a as O,t as j}from"./props-CDwtXEPn.js";import{p as F,a as K,f as U,s as E,g as G,n as X,d as Y}from"./index-client-0IVJ1HVs.js";import{M as L,J as T,n as q,K as W,N as C,O as Z,Q as _,u as z,V as w,p as J,U as Q,l as ee,c as te,d as se,C as ne,E as ie,S as ae,A as re,H as le}from"./create-runtime-stories-DlYX6Gso.js";import{_ as k}from"./iframe-DXvAOt9X.js";import"./index-D-8MO0q_.js";import"./index-BHYIh-Xd.js";import"./_commonjsHelpers-Cpj98o6Y.js";import"../sb-preview/runtime.js";L._LinesMeshParser=(o,e)=>S.Parse(o,e);class S extends L{_isShaderMaterial(e){return e.getClassName()==="ShaderMaterial"}constructor(e,i=null,t=null,s=null,c,u,a,b){super(e,i,t,s,c),this.useVertexColor=u,this.useVertexAlpha=a,this.color=new T(1,1,1),this.alpha=1,this._shaderLanguage=0,s&&(this.color=s.color.clone(),this.alpha=s.alpha,this.useVertexColor=s.useVertexColor,this.useVertexAlpha=s.useVertexAlpha),this.intersectionThreshold=.1;const m=[],n={attributes:[_.PositionKind],uniforms:["world","viewProjection"],needAlphaBlending:!0,defines:m,useClipPlane:null,shaderLanguage:0};a?n.defines.push("#define VERTEXALPHA"):n.needAlphaBlending=!1,u?(n.defines.push("#define VERTEXCOLOR"),n.attributes.push(_.ColorKind)):(n.uniforms.push("color"),this._color4=new q),b?this.material=b:(this.getScene().getEngine().isWebGPU&&!S.ForceGLSL&&(this._shaderLanguage=1),n.shaderLanguage=this._shaderLanguage,n.extraInitializationsAsync=async()=>{this._shaderLanguage===1?await Promise.all([k(()=>import("./color.vertex-DyanIhrR.js"),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11]),import.meta.url),k(()=>import("./color.fragment-Dmriqbf4.js"),__vite__mapDeps([12,1,2,3,4,5,6,7,13,14]),import.meta.url)]):await Promise.all([k(()=>import("./color.vertex-9_e37f4e.js"),__vite__mapDeps([15,1,2,3,4,5,6,7,16]),import.meta.url),k(()=>import("./color.fragment-CCDeVv6l.js"),__vite__mapDeps([17,1,2,3,4,5,6,7,18]),import.meta.url)])},this.material=new W("colorShader",this.getScene(),"color",n,!1),this.material.doNotSerialize=!0)}isReady(){return this._lineMaterial.isReady(this,!!this._userInstancedBuffersStorage||this.hasThinInstances)?super.isReady():!1}getClassName(){return"LinesMesh"}get material(){return this._lineMaterial}set material(e){this._lineMaterial=e,this._lineMaterial.fillMode=C.LineListDrawMode}get checkCollisions(){return!1}set checkCollisions(e){}_bind(e,i){if(!this._geometry)return this;const t=this.isUnIndexed?null:this._geometry.getIndexBuffer();if(!this._userInstancedBuffersStorage||this.hasThinInstances?this._geometry._bind(i,t):this._geometry._bind(i,t,this._userInstancedBuffersStorage.vertexBuffers,this._userInstancedBuffersStorage.vertexArrayObjects),!this.useVertexColor&&this._isShaderMaterial(this._lineMaterial)){const{r:s,g:c,b:u}=this.color;this._color4.set(s,c,u,this.alpha),this._lineMaterial.setColor4("color",this._color4)}return this}_draw(e,i,t){if(!this._geometry||!this._geometry.getVertexBuffers()||!this._unIndexed&&!this._geometry.getIndexBuffer())return this;const s=this.getScene().getEngine();return this._unIndexed?s.drawArraysType(C.LineListDrawMode,e.verticesStart,e.verticesCount,t):s.drawElementsType(C.LineListDrawMode,e.indexStart,e.indexCount,t),this}dispose(e,i=!1,t){t||this._lineMaterial.dispose(!1,!1,!0),super.dispose(e)}clone(e,i=null,t){return new S(e,this.getScene(),i,this,t)}createInstance(e){const i=new oe(e,this);if(this.instancedBuffers){i.instancedBuffers={};for(const t in this.instancedBuffers)i.instancedBuffers[t]=this.instancedBuffers[t]}return i}serialize(e){super.serialize(e),e.color=this.color.asArray(),e.alpha=this.alpha}static Parse(e,i){const t=new S(e.name,i);return t.color=T.FromArray(e.color),t.alpha=e.alpha,t}}S.ForceGLSL=!1;class oe extends Z{constructor(e,i){super(e,i),this.intersectionThreshold=i.intersectionThreshold}getClassName(){return"InstancedLinesMesh"}}function I(o){const e=[],i=[],t=o.lines,s=o.colors,c=[];let u=0;for(let b=0;b<t.length;b++){const m=t[b];for(let n=0;n<m.length;n++){const{x:r,y:h,z:y}=m[n];if(i.push(r,h,y),s){const l=s[b],{r:f,g:d,b:x,a:g}=l[n];c.push(f,d,x,g)}n>0&&(e.push(u-1),e.push(u)),u++}}const a=new z;return a.indices=e,a.positions=i,s&&(a.colors=c),a}function M(o){const e=o.dashSize||3,i=o.gapSize||1,t=o.dashNb||200,s=o.points,c=[],u=[],a=w.Zero();let b=0,m=0,n=0,r=0,h=0,y=0,l=0;for(l=0;l<s.length-1;l++)s[l+1].subtractToRef(s[l],a),b+=a.length();for(n=b/t,r=e*n/(e+i),l=0;l<s.length-1;l++){s[l+1].subtractToRef(s[l],a),m=Math.floor(a.length()/n),a.normalize();for(let d=0;d<m;d++)h=n*d,c.push(s[l].x+h*a.x,s[l].y+h*a.y,s[l].z+h*a.z),c.push(s[l].x+(h+r)*a.x,s[l].y+(h+r)*a.y,s[l].z+(h+r)*a.z),u.push(y,y+1),y+=2}const f=new z;return f.positions=c,f.indices=u,f}function ce(o,e,i=null){const t=e.instance,s=e.lines,c=e.colors;if(t){const m=t.getVerticesData(_.PositionKind);let n,r;c&&(n=t.getVerticesData(_.ColorKind));let h=0,y=0;for(let l=0;l<s.length;l++){const f=s[l];for(let d=0;d<f.length;d++)m[h]=f[d].x,m[h+1]=f[d].y,m[h+2]=f[d].z,c&&n&&(r=c[l],n[y]=r[d].r,n[y+1]=r[d].g,n[y+2]=r[d].b,n[y+3]=r[d].a,y+=4),h+=3}return t.updateVerticesData(_.PositionKind,m,!1,!1),c&&n&&t.updateVerticesData(_.ColorKind,n,!1,!1),t.refreshBoundingInfo(),t}const u=!!c,a=new S(o,i,null,void 0,void 0,u,e.useVertexAlpha,e.material);return I(e).applyToMesh(a,e.updatable),a}function de(o,e,i=null){const t=e.colors?[e.colors]:null;return ce(o,{lines:[e.points],updatable:e.updatable,instance:e.instance,colors:t,useVertexAlpha:e.useVertexAlpha,material:e.material},i)}function V(o,e,i=null){const t=e.points,s=e.instance,c=e.gapSize||1,u=e.dashSize||3;if(s){const m=n=>{const r=w.Zero(),h=n.length/6;let y=0,l=0,f=0,d=0,x=0,g=0,p=0,v=0;for(p=0;p<t.length-1;p++)t[p+1].subtractToRef(t[p],r),y+=r.length();f=y/h;const D=s._creationDataStorage.dashSize,R=s._creationDataStorage.gapSize;for(d=D*f/(D+R),p=0;p<t.length-1;p++)for(t[p+1].subtractToRef(t[p],r),l=Math.floor(r.length()/f),r.normalize(),v=0;v<l&&g<n.length;)x=f*v,n[g]=t[p].x+x*r.x,n[g+1]=t[p].y+x*r.y,n[g+2]=t[p].z+x*r.z,n[g+3]=t[p].x+(x+d)*r.x,n[g+4]=t[p].y+(x+d)*r.y,n[g+5]=t[p].z+(x+d)*r.z,g+=6,v++;for(;g<n.length;)n[g]=t[p].x,n[g+1]=t[p].y,n[g+2]=t[p].z,g+=3};return(e.dashNb||e.dashSize||e.gapSize||e.useVertexAlpha||e.material)&&J.Warn("You have used an option other than points with the instance option. Please be aware that these other options will be ignored."),s.updateMeshPositions(m,!1),s}const a=new S(o,i,null,void 0,void 0,void 0,e.useVertexAlpha,e.material);return M(e).applyToMesh(a,e.updatable),a._creationDataStorage=new Q,a._creationDataStorage.dashSize=u,a._creationDataStorage.gapSize=c,a}z.CreateLineSystem=I;z.CreateDashedLines=M;L.CreateLines=(o,e,i=null,t=!1,s=null)=>de(o,{points:e,updatable:t,instance:s},i);L.CreateDashedLines=(o,e,i,t,s,c=null,u,a)=>V(o,{points:e,dashSize:i,gapSize:t,dashNb:s,updatable:u,instance:a},c);function P(o,e){let i=B(e,"mesh",15),t=$(e,["$$slots","$$events","$$legacy","mesh"]);ee(o,N({createMeshFunction:V},()=>t,{get mesh(){return i()},set mesh(s){i(s)}}))}P.__docgen={data:[{name:"mesh",visibility:"public",description:"if you want to use a mesh api, bind it",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"LinesMesh"},static:!1,readonly:!1,defaultValue:"..."},{name:"options",visibility:"public",keywords:[{name:"required",description:""}],kind:"let",type:{kind:"type",type:"object",text:"{ dashNb?: number | undefined; dashSize?: number | undefined; gapSize?: number | undefined; instance?: LinesMesh | undefined; material?: Material | undefined; points: Vector3[]; updatable?: boolean | undefined; useVertexAlpha?: boolean | undefined; }"},static:!1,readonly:!1},{name:"scene",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"Scene"},static:!1,readonly:!1},{name:"children",visibility:"public",keywords:[],kind:"let",type:{kind:"function",text:"Snippet<[]>"},static:!1,readonly:!1},{name:"physics",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"boolean",text:"boolean"},static:!1,readonly:!1},{name:"physicsShape",visibility:"public",keywords:[],kind:"let",type:{kind:"union",type:[{kind:"const",type:"number",value:0,text:"PhysicsShapeType.SPHERE"},{kind:"const",type:"number",value:1,text:"PhysicsShapeType.CAPSULE"},{kind:"const",type:"number",value:2,text:"PhysicsShapeType.CYLINDER"},{kind:"const",type:"number",value:3,text:"PhysicsShapeType.BOX"},{kind:"const",type:"number",value:4,text:"PhysicsShapeType.CONVEX_HULL"},{kind:"const",type:"number",value:5,text:"PhysicsShapeType.CONTAINER"},{kind:"const",type:"number",value:6,text:"PhysicsShapeType.MESH"},{kind:"const",type:"number",value:7,text:"PhysicsShapeType.HEIGHTFIELD"},{kind:"type",type:"object",text:"PhysicsShape"}],text:"PhysicsShapeType.SPHERE | PhysicsShapeType.CAPSULE | PhysicsShapeType.CYLINDER | PhysicsShapeType.BOX | PhysicsShapeType.CONVEX_HULL | PhysicsShapeType.CONTAINER | PhysicsShapeType.MESH | PhysicsShapeType.HEIGHTFIELD | PhysicsShape"},static:!1,readonly:!1},{name:"physicsOptions",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"PhysicsAggregateParameters"},static:!1,readonly:!1},{name:"position",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"{ x: number; y: number; z: number; }"},static:!1,readonly:!1},{name:"rotation",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"{ x: number; y: number; z: number; }"},static:!1,readonly:!1},{name:"scaling",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"{ x: number; y: number; z: number; }"},static:!1,readonly:!1},{name:"force",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"{ x: number; y: number; z: number; }"},static:!1,readonly:!1},{name:"impulse",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"{ x: number; y: number; z: number; }"},static:!1,readonly:!1},{name:"collideAgainstForce",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"{ x: number; y: number; z: number; }"},static:!1,readonly:!1},{name:"collideAgainstImpulse",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"{ x: number; y: number; z: number; }"},static:!1,readonly:!1},{name:"receiveShadows",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"boolean",text:"boolean"},static:!1,readonly:!1},{name:"shadowEnabled",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"boolean",text:"boolean"},static:!1,readonly:!1},{name:"shadowGroup",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"array",text:"string[]"},static:!1,readonly:!1},{name:"onCollision",visibility:"public",keywords:[],kind:"let",type:{kind:"function",text:"(eventData: IPhysicsCollisionEvent, eventState: EventState) => void"},static:!1,readonly:!1},{name:"onCollisionOnce",visibility:"public",keywords:[],kind:"let",type:{kind:"function",text:"(eventData: IPhysicsCollisionEvent, eventState: EventState) => void"},static:!1,readonly:!1}],name:"DashedLine.svelte"};const he={title:"mesh/DashedLine",tags:["autodocs"],component:P},{Story:pe}=se();var ue=j("<!> <!> <!>",1);function A(o,e){F(e,!1),H(),pe(o,{name:"Docs",args:{options:{dashNb:20,dashSize:4,gapSize:4,instance:void 0,material:void 0,points:[{x:-2,y:4,z:-8},{x:2,y:4,z:-8}],updatable:void 0,useVertexAlpha:void 0},position:{x:0,y:0,z:0},rotation:{x:0,y:0,z:0},scaling:{x:1,y:1,z:1}},parameters:{docs:{canvas:{sourceState:"shown"},source:{code:`<Canvas style="width: 100%;">
  <Engine>
    <Scene physics={false}>
      <ArcRotateCamera alpha={Math.PI / 2} beta={Math.PI / 2} radius={10} />
      <HemisphericLight direction={new Vector3(0, 1, 0)} intensity={0.7} />
      <DashedLine
        options={{
          dashNb: 20,
          dashSize: 4,
          gapSize: 4,
          points: [
            { x: -2, y: 4, z: -8 },
            { x: 2, y: 4, z: -8 }
          ]
        }}
        position={{ x: 0, y: 0, z: 0 }}
        rotation={{ x: 0, y: 0, z: 0 }}
        scaling={{ x: 1, y: 1, z: 1 }}
      />
    </Scene>
  </Engine>
</Canvas>`}},__svelteCsf:{rawCode:`<Canvas style="width: 100%;">
  <Engine>
    <Scene physics={false}>
      <ArcRotateCamera alpha={Math.PI / 2} beta={Math.PI / 2} radius={10} />
      <HemisphericLight direction={new Vector3(0, 1, 0)} intensity={0.7} />
      <DashedLine
        options={{
          ...args.options,
          points:
            args.options?.points.map((point) => new Vector3(point.x, point.y, point.z)) || []
        }}
        position={args.position}
        rotation={args.rotation}
        scaling={args.scaling}
      />
    </Scene>
  </Engine>
</Canvas>`}},children:(t,s=X)=>{ne(t,{style:"width: 100%;",children:(c,u)=>{ie(c,{children:(a,b)=>{ae(a,{physics:!1,children:(m,n)=>{var r=ue(),h=U(r);re(h,{alpha:Math.PI/2,beta:Math.PI/2,radius:10});var y=E(h,2);le(y,{direction:new w(0,1,0),intensity:.7});var l=E(y,2),f=Y(()=>{var d;return{...s().options,points:((d=s().options)==null?void 0:d.points.map(x=>new w(x.x,x.y,x.z)))||[]}});P(l,{get options(){return G(f)},get position(){return s().position},get rotation(){return s().rotation},get scaling(){return s().scaling}}),O(m,r)},$$slots:{default:!0}})},$$slots:{default:!0}})},$$slots:{default:!0}})},$$slots:{default:!0}}),K()}A.__docgen={version:3,name:"DashedLine.stories.svelte",data:[],computed:[],methods:[],components:[],description:null,keywords:[],events:[],slots:[],refs:[]};const ye=te(A,he),ke=["Docs"],we=ye.Docs;export{we as Docs,ke as __namedExportsOrder,he as default};
