const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./color.vertex-zkdd0_ve.js","./create-runtime-stories-ChL5sEf5.js","./props-CDwtXEPn.js","./index-client-0IVJ1HVs.js","./iframe-BnamMGfJ.js","./index-D-8MO0q_.js","./index-BHYIh-Xd.js","./_commonjsHelpers-Cpj98o6Y.js","./vertexColorMixing-CF9wStrQ.js","./instancesVertex-CBfEuj0a.js","./color.fragment-Ds1bwXrv.js","./fogFragment-lIYosmXA.js","./color.vertex-BciDr3ES.js","./vertexColorMixing-CZSP_i9v.js","./instancesVertex-BX44DCjt.js","./color.fragment-DZD623-w.js","./fogFragment-CHkDbJXm.js"])))=>i.map(i=>d[i]);
import{p as j,s as $,r as N,i as G,a as K,t as H}from"./props-CDwtXEPn.js";import{p as Q,a as q,f as U,g as X,n as Y,s as O,d as Z}from"./index-client-0IVJ1HVs.js";import{M as b,D as J,T as B,o as w,G as x,J as ee,v as te,K as R,N as se,O as ne,Q as T,m as re,U as ie,W as A,t as L,V as I,X as ae,e as oe,f as he,g as ce,i as ue,j as le,k as de,F as fe,H as ge}from"./create-runtime-stories-ChL5sEf5.js";import{_ as v}from"./iframe-BnamMGfJ.js";import"./index-D-8MO0q_.js";import"./index-BHYIh-Xd.js";import"./_commonjsHelpers-Cpj98o6Y.js";import"../sb-preview/runtime.js";b._instancedMeshFactory=(r,e)=>{const s=new V(r,e);if(e.instancedBuffers){s.instancedBuffers={};for(const t in e.instancedBuffers)s.instancedBuffers[t]=e.instancedBuffers[t]}return s};class V extends J{constructor(e,s){super(e,s.getScene()),this._indexInSourceMeshInstanceArray=-1,this._distanceToCamera=0,s.addInstance(this),this._sourceMesh=s,this._unIndexed=s._unIndexed,this.position.copyFrom(s.position),this.rotation.copyFrom(s.rotation),this.scaling.copyFrom(s.scaling),s.rotationQuaternion&&(this.rotationQuaternion=s.rotationQuaternion.clone()),this.animations=s.animations.slice();for(const t of s.getAnimationRanges())t!=null&&this.createAnimationRange(t.name,t.from,t.to);this.infiniteDistance=s.infiniteDistance,this.setPivotMatrix(s.getPivotMatrix()),this.refreshBoundingInfo(!0,!0),this._syncSubMeshes()}getClassName(){return"InstancedMesh"}get lightSources(){return this._sourceMesh._lightSources}_resyncLightSources(){}_resyncLightSource(){}_removeLightSource(){}get receiveShadows(){return this._sourceMesh.receiveShadows}set receiveShadows(e){var s;((s=this._sourceMesh)==null?void 0:s.receiveShadows)!==e&&B.Warn("Setting receiveShadows on an instanced mesh has no effect")}get material(){return this._sourceMesh.material}set material(e){var s;((s=this._sourceMesh)==null?void 0:s.material)!==e&&B.Warn("Setting material on an instanced mesh has no effect")}get visibility(){return this._sourceMesh.visibility}set visibility(e){var s;((s=this._sourceMesh)==null?void 0:s.visibility)!==e&&B.Warn("Setting visibility on an instanced mesh has no effect")}get skeleton(){return this._sourceMesh.skeleton}set skeleton(e){var s;((s=this._sourceMesh)==null?void 0:s.skeleton)!==e&&B.Warn("Setting skeleton on an instanced mesh has no effect")}get renderingGroupId(){return this._sourceMesh.renderingGroupId}set renderingGroupId(e){!this._sourceMesh||e===this._sourceMesh.renderingGroupId||w.Warn("Note - setting renderingGroupId of an instanced mesh has no effect on the scene")}getTotalVertices(){return this._sourceMesh?this._sourceMesh.getTotalVertices():0}getTotalIndices(){return this._sourceMesh.getTotalIndices()}get sourceMesh(){return this._sourceMesh}createInstance(e){return this._sourceMesh.createInstance(e)}isReady(e=!1){return this._sourceMesh.isReady(e,!0)}getVerticesData(e,s,t){return this._sourceMesh.getVerticesData(e,s,t)}copyVerticesData(e,s){this._sourceMesh.copyVerticesData(e,s)}setVerticesData(e,s,t,n){return this.sourceMesh&&this.sourceMesh.setVerticesData(e,s,t,n),this.sourceMesh}updateVerticesData(e,s,t,n){return this.sourceMesh&&this.sourceMesh.updateVerticesData(e,s,t,n),this.sourceMesh}setIndices(e,s=null){return this.sourceMesh&&this.sourceMesh.setIndices(e,s),this.sourceMesh}isVerticesDataPresent(e){return this._sourceMesh.isVerticesDataPresent(e)}getIndices(){return this._sourceMesh.getIndices()}get _positions(){return this._sourceMesh._positions}refreshBoundingInfo(e=!1,s=!1){if(this.hasBoundingInfo&&this.getBoundingInfo().isLocked)return this;let t;typeof e=="object"?t=e:t={applySkeleton:e,applyMorph:s};const n=this._sourceMesh.geometry?this._sourceMesh.geometry.boundingBias:null;return this._refreshBoundingInfo(this._sourceMesh._getData(t,null,x.PositionKind),n),this}_preActivate(){return this._currentLOD&&this._currentLOD._preActivate(),this}_activate(e,s){if(super._activate(e,s),this._sourceMesh.subMeshes||w.Warn("Instances should only be created for meshes with geometry."),this._currentLOD){if(this._currentLOD._getWorldMatrixDeterminant()>=0!=this._getWorldMatrixDeterminant()>=0)return this._internalAbstractMeshDataInfo._actAsRegularMesh=!0,!0;if(this._internalAbstractMeshDataInfo._actAsRegularMesh=!1,this._currentLOD._registerInstanceForRenderId(this,e),s){if(!this._currentLOD._internalAbstractMeshDataInfo._isActiveIntermediate)return this._currentLOD._internalAbstractMeshDataInfo._onlyForInstancesIntermediate=!0,!0}else if(!this._currentLOD._internalAbstractMeshDataInfo._isActive)return this._currentLOD._internalAbstractMeshDataInfo._onlyForInstances=!0,!0}return!1}_postActivate(){this._sourceMesh.edgesShareWithInstances&&this._sourceMesh._edgesRenderer&&this._sourceMesh._edgesRenderer.isEnabled&&this._sourceMesh._renderingGroup?(this._sourceMesh._renderingGroup._edgesRenderers.pushNoDuplicate(this._sourceMesh._edgesRenderer),this._sourceMesh._edgesRenderer.customInstances.push(this.getWorldMatrix())):this._edgesRenderer&&this._edgesRenderer.isEnabled&&this._sourceMesh._renderingGroup&&this._sourceMesh._renderingGroup._edgesRenderers.push(this._edgesRenderer)}getWorldMatrix(){if(this._currentLOD&&this._currentLOD.billboardMode!==ee.BILLBOARDMODE_NONE&&this._currentLOD._masterMesh!==this){this._billboardWorldMatrix||(this._billboardWorldMatrix=new te);const e=this._currentLOD._masterMesh;return this._currentLOD._masterMesh=this,R.Vector3[7].copyFrom(this._currentLOD.position),this._currentLOD.position.set(0,0,0),this._billboardWorldMatrix.copyFrom(this._currentLOD.computeWorldMatrix(!0)),this._currentLOD.position.copyFrom(R.Vector3[7]),this._currentLOD._masterMesh=e,this._billboardWorldMatrix}return super.getWorldMatrix()}get isAnInstance(){return!0}getLOD(e){if(!e)return this;const s=this.sourceMesh.getLODLevels();if(!s||s.length===0)this._currentLOD=this.sourceMesh;else{const t=this.getBoundingInfo();this._currentLOD=this.sourceMesh.getLOD(e,t.boundingSphere)}return this._currentLOD}_preActivateForIntermediateRendering(e){return this.sourceMesh._preActivateForIntermediateRendering(e)}_syncSubMeshes(){if(this.releaseSubMeshes(),this._sourceMesh.subMeshes)for(let e=0;e<this._sourceMesh.subMeshes.length;e++)this._sourceMesh.subMeshes[e].clone(this,this._sourceMesh);return this}_generatePointsArray(){return this._sourceMesh._generatePointsArray()}_updateBoundingInfo(){return this.hasBoundingInfo?this.getBoundingInfo().update(this.worldMatrixFromCache):this.buildBoundingInfo(this.absolutePosition,this.absolutePosition,this.worldMatrixFromCache),this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache),this}clone(e,s=null,t,n){const o=(n||this._sourceMesh).createInstance(e);if(se.DeepCopy(this,o,["name","subMeshes","uniqueId","parent","lightSources","receiveShadows","material","visibility","skeleton","sourceMesh","isAnInstance","facetNb","isFacetDataEnabled","isBlocked","useBones","hasInstances","collider","edgesRenderer","forward","up","right","absolutePosition","absoluteScaling","absoluteRotationQuaternion","isWorldMatrixFrozen","nonUniformScaling","behaviors","worldMatrixFromCache","hasThinInstances","hasBoundingInfo"],[]),this.refreshBoundingInfo(),s&&(o.parent=s),!t)for(let l=0;l<this.getScene().meshes.length;l++){const i=this.getScene().meshes[l];i.parent===this&&i.clone(i.name,o)}return o.computeWorldMatrix(!0),this.onClonedObservable.notifyObservers(o),o}dispose(e,s=!1){this._sourceMesh.removeInstance(this),super.dispose(e,s)}_serializeAsParent(e){super._serializeAsParent(e),e.parentId=this._sourceMesh.uniqueId,e.parentInstanceIndex=this._indexInSourceMeshInstanceArray}instantiateHierarchy(e=null,s,t){const n=this.clone("Clone of "+(this.name||this.id),e||this.parent,!0,s&&s.newSourcedMesh);n&&t&&t(this,n);for(const o of this.getChildTransformNodes(!0))o.instantiateHierarchy(n,s,t);return n}}b.prototype.registerInstancedBuffer=function(r,e){var s,t;if((t=(s=this._userInstancedBuffersStorage)==null?void 0:s.vertexBuffers[r])==null||t.dispose(),!this.instancedBuffers){this.instancedBuffers={};for(const n of this.instances)n.instancedBuffers={}}this._userInstancedBuffersStorage||(this._userInstancedBuffersStorage={data:{},vertexBuffers:{},strides:{},sizes:{},vertexArrayObjects:this.getEngine().getCaps().vertexArrayObject?{}:void 0}),this.instancedBuffers[r]=null,this._userInstancedBuffersStorage.strides[r]=e,this._userInstancedBuffersStorage.sizes[r]=e*32,this._userInstancedBuffersStorage.data[r]=new Float32Array(this._userInstancedBuffersStorage.sizes[r]),this._userInstancedBuffersStorage.vertexBuffers[r]=new x(this.getEngine(),this._userInstancedBuffersStorage.data[r],r,!0,!1,e,!0);for(const n of this.instances)n.instancedBuffers[r]=null;this._invalidateInstanceVertexArrayObject(),this._markSubMeshesAsAttributesDirty()};b.prototype._processInstancedBuffers=function(r,e){const s=r?r.length:0;for(const t in this.instancedBuffers){let n=this._userInstancedBuffersStorage.sizes[t];const o=this._userInstancedBuffersStorage.strides[t],l=(s+1)*o;for(;n<l;)n*=2;this._userInstancedBuffersStorage.data[t].length!=n&&(this._userInstancedBuffersStorage.data[t]=new Float32Array(n),this._userInstancedBuffersStorage.sizes[t]=n,this._userInstancedBuffersStorage.vertexBuffers[t]&&(this._userInstancedBuffersStorage.vertexBuffers[t].dispose(),this._userInstancedBuffersStorage.vertexBuffers[t]=null));const i=this._userInstancedBuffersStorage.data[t];let d=0;if(e){const u=this.instancedBuffers[t];u.toArray?u.toArray(i,d):u.copyToArray?u.copyToArray(i,d):i[d]=u,d+=o}for(let u=0;u<s;u++){const h=r[u].instancedBuffers[t];h.toArray?h.toArray(i,d):h.copyToArray?h.copyToArray(i,d):i[d]=h,d+=o}this._userInstancedBuffersStorage.vertexBuffers[t]?this._userInstancedBuffersStorage.vertexBuffers[t].updateDirectly(i,0):(this._userInstancedBuffersStorage.vertexBuffers[t]=new x(this.getEngine(),this._userInstancedBuffersStorage.data[t],t,!0,!1,o,!0),this._invalidateInstanceVertexArrayObject())}};b.prototype._invalidateInstanceVertexArrayObject=function(){if(!(!this._userInstancedBuffersStorage||this._userInstancedBuffersStorage.vertexArrayObjects===void 0)){for(const r in this._userInstancedBuffersStorage.vertexArrayObjects)this.getEngine().releaseVertexArrayObject(this._userInstancedBuffersStorage.vertexArrayObjects[r]);this._userInstancedBuffersStorage.vertexArrayObjects={}}};b.prototype._disposeInstanceSpecificData=function(){for(this._instanceDataStorage.instancesBuffer&&(this._instanceDataStorage.instancesBuffer.dispose(),this._instanceDataStorage.instancesBuffer=null);this.instances.length;)this.instances[0].dispose();for(const r in this.instancedBuffers)this._userInstancedBuffersStorage.vertexBuffers[r]&&this._userInstancedBuffersStorage.vertexBuffers[r].dispose();this._invalidateInstanceVertexArrayObject(),this.instancedBuffers={}};ne("BABYLON.InstancedMesh",V);b._LinesMeshParser=(r,e)=>S.Parse(r,e);class S extends b{_isShaderMaterial(e){return e.getClassName()==="ShaderMaterial"}constructor(e,s=null,t=null,n=null,o,l,i,d){super(e,s,t,n,o),this.useVertexColor=l,this.useVertexAlpha=i,this.color=new T(1,1,1),this.alpha=1,this._shaderLanguage=0,n&&(this.color=n.color.clone(),this.alpha=n.alpha,this.useVertexColor=n.useVertexColor,this.useVertexAlpha=n.useVertexAlpha),this.intersectionThreshold=.1;const u=[],a={attributes:[x.PositionKind],uniforms:["world","viewProjection"],needAlphaBlending:!0,defines:u,useClipPlane:null,shaderLanguage:0};i?a.defines.push("#define VERTEXALPHA"):a.needAlphaBlending=!1,l?(a.defines.push("#define VERTEXCOLOR"),a.attributes.push(x.ColorKind)):(a.uniforms.push("color"),this._color4=new re),d?this.material=d:(this.getScene().getEngine().isWebGPU&&!S.ForceGLSL&&(this._shaderLanguage=1),a.shaderLanguage=this._shaderLanguage,a.extraInitializationsAsync=async()=>{this._shaderLanguage===1?await Promise.all([v(()=>import("./color.vertex-zkdd0_ve.js"),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9]),import.meta.url),v(()=>import("./color.fragment-Ds1bwXrv.js"),__vite__mapDeps([10,1,2,3,4,5,6,7,11]),import.meta.url)]):await Promise.all([v(()=>import("./color.vertex-BciDr3ES.js"),__vite__mapDeps([12,1,2,3,4,5,6,7,13,14]),import.meta.url),v(()=>import("./color.fragment-DZD623-w.js"),__vite__mapDeps([15,1,2,3,4,5,6,7,16]),import.meta.url)])},this.material=new ie("colorShader",this.getScene(),"color",a,!1),this.material.doNotSerialize=!0)}isReady(){return this._lineMaterial.isReady(this,!!this._userInstancedBuffersStorage||this.hasThinInstances)?super.isReady():!1}getClassName(){return"LinesMesh"}get material(){return this._lineMaterial}set material(e){this._lineMaterial=e,this._lineMaterial.fillMode=A.LineListDrawMode}get checkCollisions(){return!1}set checkCollisions(e){}_bind(e,s){if(!this._geometry)return this;const t=this.isUnIndexed?null:this._geometry.getIndexBuffer();if(!this._userInstancedBuffersStorage||this.hasThinInstances?this._geometry._bind(s,t):this._geometry._bind(s,t,this._userInstancedBuffersStorage.vertexBuffers,this._userInstancedBuffersStorage.vertexArrayObjects),!this.useVertexColor&&this._isShaderMaterial(this._lineMaterial)){const{r:n,g:o,b:l}=this.color;this._color4.set(n,o,l,this.alpha),this._lineMaterial.setColor4("color",this._color4)}return this}_draw(e,s,t){if(!this._geometry||!this._geometry.getVertexBuffers()||!this._unIndexed&&!this._geometry.getIndexBuffer())return this;const n=this.getScene().getEngine();return this._unIndexed?n.drawArraysType(A.LineListDrawMode,e.verticesStart,e.verticesCount,t):n.drawElementsType(A.LineListDrawMode,e.indexStart,e.indexCount,t),this}dispose(e,s=!1,t){t||this._lineMaterial.dispose(!1,!1,!0),super.dispose(e)}clone(e,s=null,t){return new S(e,this.getScene(),s,this,t)}createInstance(e){const s=new _e(e,this);if(this.instancedBuffers){s.instancedBuffers={};for(const t in this.instancedBuffers)s.instancedBuffers[t]=this.instancedBuffers[t]}return s}serialize(e){super.serialize(e),e.color=this.color.asArray(),e.alpha=this.alpha}static Parse(e,s){const t=new S(e.name,s);return t.color=T.FromArray(e.color),t.alpha=e.alpha,t}}S.ForceGLSL=!1;class _e extends V{constructor(e,s){super(e,s),this.intersectionThreshold=s.intersectionThreshold}getClassName(){return"InstancedLinesMesh"}}function P(r){const e=[],s=[],t=r.lines,n=r.colors,o=[];let l=0;for(let d=0;d<t.length;d++){const u=t[d];for(let a=0;a<u.length;a++){const{x:h,y:g,z:p}=u[a];if(s.push(h,g,p),n){const c=n[d],{r:y,g:f,b:M,a:m}=c[a];o.push(y,f,M,m)}a>0&&(e.push(l-1),e.push(l)),l++}}const i=new L;return i.indices=e,i.positions=s,n&&(i.colors=o),i}function k(r){const e=r.dashSize||3,s=r.gapSize||1,t=r.dashNb||200,n=r.points,o=[],l=[],i=I.Zero();let d=0,u=0,a=0,h=0,g=0,p=0,c=0;for(c=0;c<n.length-1;c++)n[c+1].subtractToRef(n[c],i),d+=i.length();for(a=d/t,h=e*a/(e+s),c=0;c<n.length-1;c++){n[c+1].subtractToRef(n[c],i),u=Math.floor(i.length()/a),i.normalize();for(let f=0;f<u;f++)g=a*f,o.push(n[c].x+g*i.x,n[c].y+g*i.y,n[c].z+g*i.z),o.push(n[c].x+(g+h)*i.x,n[c].y+(g+h)*i.y,n[c].z+(g+h)*i.z),l.push(p,p+1),p+=2}const y=new L;return y.positions=o,y.indices=l,y}function pe(r,e,s=null){const t=e.instance,n=e.lines,o=e.colors;if(t){const u=t.getVerticesData(x.PositionKind);let a,h;o&&(a=t.getVerticesData(x.ColorKind));let g=0,p=0;for(let c=0;c<n.length;c++){const y=n[c];for(let f=0;f<y.length;f++)u[g]=y[f].x,u[g+1]=y[f].y,u[g+2]=y[f].z,o&&a&&(h=o[c],a[p]=h[f].r,a[p+1]=h[f].g,a[p+2]=h[f].b,a[p+3]=h[f].a,p+=4),g+=3}return t.updateVerticesData(x.PositionKind,u,!1,!1),o&&a&&t.updateVerticesData(x.ColorKind,a,!1,!1),t.refreshBoundingInfo(),t}const l=!!o,i=new S(r,s,null,void 0,void 0,l,e.useVertexAlpha,e.material);return P(e).applyToMesh(i,e.updatable),i}function ye(r,e,s=null){const t=e.colors?[e.colors]:null;return pe(r,{lines:[e.points],updatable:e.updatable,instance:e.instance,colors:t,useVertexAlpha:e.useVertexAlpha,material:e.material},s)}function F(r,e,s=null){const t=e.points,n=e.instance,o=e.gapSize||1,l=e.dashSize||3;if(n){const u=a=>{const h=I.Zero(),g=a.length/6;let p=0,c=0,y=0,f=0,M=0,m=0,_=0,D=0;for(_=0;_<t.length-1;_++)t[_+1].subtractToRef(t[_],h),p+=h.length();y=p/g;const C=n._creationDataStorage.dashSize,W=n._creationDataStorage.gapSize;for(f=C*y/(C+W),_=0;_<t.length-1;_++)for(t[_+1].subtractToRef(t[_],h),c=Math.floor(h.length()/y),h.normalize(),D=0;D<c&&m<a.length;)M=y*D,a[m]=t[_].x+M*h.x,a[m+1]=t[_].y+M*h.y,a[m+2]=t[_].z+M*h.z,a[m+3]=t[_].x+(M+f)*h.x,a[m+4]=t[_].y+(M+f)*h.y,a[m+5]=t[_].z+(M+f)*h.z,m+=6,D++;for(;m<a.length;)a[m]=t[_].x,a[m+1]=t[_].y,a[m+2]=t[_].z,m+=3};return(e.dashNb||e.dashSize||e.gapSize||e.useVertexAlpha||e.material)&&w.Warn("You have used an option other than points with the instance option. Please be aware that these other options will be ignored."),n.updateMeshPositions(u,!1),n}const i=new S(r,s,null,void 0,void 0,void 0,e.useVertexAlpha,e.material);return k(e).applyToMesh(i,e.updatable),i._creationDataStorage=new ae,i._creationDataStorage.dashSize=l,i._creationDataStorage.gapSize=o,i}L.CreateLineSystem=P;L.CreateDashedLines=k;b.CreateLines=(r,e,s=null,t=!1,n=null)=>ye(r,{points:e,updatable:t,instance:n},s);b.CreateDashedLines=(r,e,s,t,n,o=null,l,i)=>F(r,{points:e,dashSize:s,gapSize:t,dashNb:n,updatable:l,instance:i},o);function z(r,e){let s=j(e,"mesh",15),t=N(e,["$$slots","$$events","$$legacy","mesh"]);oe(r,$({createMeshFunction:F},()=>t,{get mesh(){return s()},set mesh(n){s(n)}}))}z.__docgen={data:[{name:"mesh",visibility:"public",description:"if you want to use a mesh api, bind it",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"LinesMesh"},static:!1,readonly:!1,defaultValue:"..."},{name:"options",visibility:"public",keywords:[{name:"required",description:""}],kind:"let",type:{kind:"type",type:"object",text:"{ dashNb?: number | undefined; dashSize?: number | undefined; gapSize?: number | undefined; instance?: LinesMesh | undefined; material?: Material | undefined; points: Vector3[]; updatable?: boolean | undefined; useVertexAlpha?: boolean | undefined; }"},static:!1,readonly:!1},{name:"scene",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"Scene"},static:!1,readonly:!1},{name:"children",visibility:"public",keywords:[],kind:"let",type:{kind:"function",text:"Snippet<[]>"},static:!1,readonly:!1},{name:"position",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"{ x: number; y: number; z: number; }"},static:!1,readonly:!1},{name:"rotation",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"{ x: number; y: number; z: number; }"},static:!1,readonly:!1},{name:"scaling",visibility:"public",keywords:[],kind:"let",type:{kind:"type",type:"object",text:"{ x: number; y: number; z: number; }"},static:!1,readonly:!1}],name:"DashedLine.svelte"};const me={title:"mesh/DashedLine",tags:["autodocs"],component:z},{Story:Me}=ce();var xe=H("<!> <!> <!>",1);function E(r,e){Q(e,!1),G(),Me(r,{name:"Docs",args:{options:{dashNb:20,dashSize:4,gapSize:4,instance:void 0,material:void 0,points:[{x:-2,y:4,z:-8},{x:2,y:4,z:-8}],updatable:void 0,useVertexAlpha:void 0},position:{x:0,y:0,z:0},rotation:{x:0,y:0,z:0},scaling:{x:1,y:1,z:1}},children:(t,n=Y)=>{ue(t,{style:"width: 100%;",children:(o,l)=>{le(o,{children:(i,d)=>{de(i,{children:(u,a)=>{var h=xe(),g=U(h);fe(g,{position:new I(0,5,-10)});var p=O(g,2);ge(p,{direction:new I(0,1,0),intensity:.7});var c=O(p,2),y=Z(()=>{var f;return{...n().options,points:((f=n().options)==null?void 0:f.points.map(M=>new I(M.x,M.y,M.z)))||[]}});z(c,{get options(){return X(y)},get position(){return n().position},get rotation(){return n().rotation},get scaling(){return n().scaling}}),K(u,h)},$$slots:{default:!0}})},$$slots:{default:!0}})},$$slots:{default:!0}})},$$slots:{default:!0},parameters:{__svelteCsf:{rawCode:`<Canvas style="width: 100%;">
  <Engine>
    <Scene>
      <FreeCamera position={new Vector3(0, 5, -10)} />
      <HemisphericLight direction={new Vector3(0, 1, 0)} intensity={0.7} />
      <DashedLine
        options={{
          ...args.options,
          points:
            args.options?.points.map((point) => new Vector3(point.x, point.y, point.z)) || []
        }}
        position={args.position}
        rotation={args.rotation}
        scaling={args.scaling}
      />
    </Scene>
  </Engine>
</Canvas>`}}}),q()}E.__docgen={version:3,name:"DashedLine.stories.svelte",data:[],computed:[],methods:[],components:[],description:null,keywords:[],events:[],slots:[],refs:[]};const be=he(E,me),Ve=["Docs"],ze=be.Docs;export{ze as Docs,Ve as __namedExportsOrder,me as default};
